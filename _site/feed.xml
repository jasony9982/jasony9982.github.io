<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-22T23:27:01+08:00</updated><id>http://localhost:4000/</id><title type="html">仙居茶客</title><subtitle>袁培超的个人博客</subtitle><author><name>Peichao Yuan</name></author><entry><title type="html">iOS 保持界面流畅的技巧</title><link href="http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios/" rel="alternate" type="text/html" title="iOS 保持界面流畅的技巧" /><published>2018-05-22T00:00:00+08:00</published><updated>2018-05-22T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios</id><content type="html" xml:base="http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios/">&lt;blockquote&gt;
  &lt;p&gt;这篇文章会非常详细的分析 iOS 界面构建中的各种性能问题以及对应的解决思路，同时给出一个开源的微博列表实现，通过实际的代码展示如何构建流畅的交互。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios&quot;&gt;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Index&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;演示项目&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;屏幕显示图像的原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;卡顿产生的原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#31&quot;&gt;CPU 资源消耗原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#32&quot;&gt; GPU 资源消耗原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt; AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#41&quot;&gt;ASDK 的由来&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#42&quot;&gt;ASDK 的资料&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#43&quot;&gt;ASDK 的基本原理&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#44&quot;&gt;ASDK 的图层预合成&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#45&quot;&gt;ASDK 异步并发操作&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#46&quot;&gt;Runloop 任务分发&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;微博 Demo 性能优化技巧&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#51&quot;&gt;预排版&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#52&quot;&gt;预渲染&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#53&quot;&gt;异步绘制&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#54&quot;&gt;全局并发控制&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#55&quot;&gt;更高效的异步图片加载&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#56&quot;&gt;其他可以改进的地方&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;如何评测界面的流畅度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;演示项目&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;在开始技术讨论前，你可以先下载我写的 Demo 跑到真机上体验一下：&lt;a href=&quot;https://github.com/ibireme/YYKit&quot; target=&quot;_blank&quot;&gt;https://github.com/ibireme/YYKit&lt;/a&gt;。 Demo 里包含一个微博的 Feed 列表、发布视图，还包含一个 Twitter 的 Feed 列表。为了公平起见，所有界面和交互我都从官方应用原封不动的抄了过来，数据也都是从官方应用抓取的。你也可以自己抓取数据替换掉 Demo 中的数据，方便进行对比。尽管官方应用背后的功能更多更为复杂，但不至于会带来太大的交互性能差异。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41926&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo.png&quot; alt=&quot;weibo&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo_compose.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41927&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo_compose.png&quot; alt=&quot;weibo_compose&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/twitter.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41928&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/twitter.png&quot; alt=&quot;twitter&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;这个 Demo 最低可以运行在 iOS 6 上，所以你可以把它跑到老设备上体验一下。在我的测试中，即使在 iPhone 4S 或者 iPad 3 上，Demo 列表在快速滑动时仍然能保持 50~60 FPS 的流畅交互，而其他诸如微博、朋友圈等应用的列表视图在滑动时已经有很严重的卡顿了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;微博的 Demo 有大约四千行代码，Twitter 的只有两千行左右代码，第三方库只用到了 YYKit，文件数量比较少，方便查看。好了，下面是正文。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-41893&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;屏幕显示图像的原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41896&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png&quot; alt=&quot;ios_screen_scan&quot; width=&quot;321&quot; height=&quot;239&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41897&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png&quot; alt=&quot;ios_screen_display&quot; width=&quot;546&quot; height=&quot;251&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-41898&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg&quot; alt=&quot;ios_vsync_off&quot; width=&quot;500&quot; height=&quot;294&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;卡顿产生的原因和解决方案&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41899&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png&quot; alt=&quot;ios_frame_drop&quot; width=&quot;712&quot; height=&quot;184&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;31&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;CPU 资源消耗原因和解决方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象调整&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象销毁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&amp;lt;div id=&quot;crayon-5b043341ea225034597315&quot; class=&quot;crayon-syntax crayon-theme-familiar-mynew crayon-font-consolas crayon-os-mac print-yes notranslate&quot; data-settings=&quot; minimize scroll-mouseover wrap&quot; style=&quot; margin-top: 5px; margin-bottom: 5px; font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt;
	
		&amp;lt;div class=&quot;crayon-plain-wrap&quot;&amp;gt;&amp;lt;textarea  class=&quot;crayon-plain print-no&quot; data-settings=&quot;&quot; readonly style=&quot;-moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4; font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt; NSArray *tmp = self.array; self.array = nil; dispatch_async(queue, ^{
[tmp class]; });&amp;lt;/textarea&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;crayon-main&quot; style=&quot;&quot;&amp;gt;
			&amp;lt;table class=&quot;crayon-table&quot;&amp;gt;
				&amp;lt;tr class=&quot;crayon-row&quot;&amp;gt;
			&amp;lt;td class=&quot;crayon-nums &quot; data-settings=&quot;hide&quot;&amp;gt;
				&amp;lt;div class=&quot;crayon-nums-content&quot; style=&quot;font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-1&quot;&amp;gt;1&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-2&quot;&amp;gt;2&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-3&quot;&amp;gt;3&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-4&quot;&amp;gt;4&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-5&quot;&amp;gt;5&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;/td&amp;gt;
					&amp;lt;td class=&quot;crayon-code&quot;&amp;gt;&amp;lt;div class=&quot;crayon-pre&quot; style=&quot;font-size: 13px !important; line-height: 15px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;&quot;&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-1&quot;&amp;gt;&amp;lt;span class=&quot;crayon-e &quot;&amp;gt;NSArray *&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;tmp&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-r&quot;&amp;gt;self&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;array&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-2&quot;&amp;gt;&amp;lt;span class=&quot;crayon-r&quot;&amp;gt;self&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;array&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;nil&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-3&quot;&amp;gt;&amp;lt;span class=&quot;crayon-e&quot;&amp;gt;dispatch_async&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;queue&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;,&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;^&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;{&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-4&quot;&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-e&quot;&amp;gt;tmp &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;class&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;]&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-5&quot;&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;}&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;)&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/td&amp;gt;
				&amp;lt;/tr&amp;gt;
			&amp;lt;/table&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt; &amp;lt;!-- [Format Time: 0.0003 seconds] --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt; 布局计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;Autolayout&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：&lt;a href=&quot;http://pilky.me/36/&quot; target=&quot;_blank&quot;&gt;http://pilky.me/36/&lt;/a&gt;。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;文本计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;文本渲染&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;图片的解码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt; 图像的绘制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)display {
    dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- [Format Time: 0.0004 seconds] --&gt;
&lt;p&gt;&lt;a name=&quot;32&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt; GPU 资源消耗原因和解决方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;纹理的渲染&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096&amp;#215;4096，更详细的资料可以看这里：&lt;a href=&quot;http://iosres.com&quot; target=&quot;_blank&quot;&gt;iosres.com&lt;/a&gt;。所以，尽量不要让图片和视图的大小超过这个值。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;视图的混合 (Composing)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;图形的生成。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;AsyncDisplayKit&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;41&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的由来&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/scott_goodson.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41900&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/scott_goodson.png&quot; alt=&quot;scott_goodson&quot; width=&quot;150&quot; height=&quot;150&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 的作者是 Scott Goodson (&lt;a href=&quot;https://www.linkedin.com/in/iosengineer&quot; target=&quot;_blank&quot;&gt;Linkedin&lt;/a&gt;)，&lt;br /&gt;
他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置、Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_history.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41901&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_history.png&quot; alt=&quot;asdk_history&quot; width=&quot;484&quot; height=&quot;160&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。&lt;br /&gt;
V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。&lt;br /&gt;
现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;42&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的资料&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;想要了解 ASDK 的原理和细节，最好从下面几个视频开始：&lt;br /&gt;
2014.10.15 &lt;a href=&quot;https://www.youtube.com/watch?v=-IPMNWqA638&quot; target=&quot;_blank&quot;&gt;NSLondon &amp;#8211; Scott Goodson &amp;#8211; Behind AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
2015.03.02 &lt;a href=&quot;https://www.youtube.com/watch?v=ZPL4Nse76oY&quot; target=&quot;_blank&quot;&gt;MCE 2015 &amp;#8211; Scott Goodson &amp;#8211; Effortless Responsiveness with AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
2015.10.25 &lt;a href=&quot;https://www.youtube.com/watch?v=RY_X7l1g79Q&quot; target=&quot;_blank&quot;&gt;AsyncDisplayKit 2.0: Intelligent User Interfaces &amp;#8211; NSSpain 2015&lt;/a&gt;&lt;br /&gt;
前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。&lt;br /&gt;
后一个视频增加了 ASDK 2.0 的新特性的介绍。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容：&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/42&quot; target=&quot;_blank&quot;&gt;关于 Runloop Dispatch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/70&quot; target=&quot;_blank&quot;&gt;关于 ComponentKit 和 ASDK 的区别&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/132&quot; target=&quot;_blank&quot;&gt;为什么不支持 Storyboard 和 Autolayout&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/204&quot; target=&quot;_blank&quot;&gt;如何评测界面的流畅度&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;之后，还可以到 Google Groups 来查看和讨论更多内容：&lt;br /&gt;
&lt;a href=&quot;https://groups.google.com/forum/#!forum/asyncdisplaykit&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!forum/asyncdisplaykit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;43&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的基本原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_design.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41902&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_design.png&quot; alt=&quot;asdk_design&quot; width=&quot;496&quot; height=&quot;255&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_view.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41903&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_view.png&quot; alt=&quot;asdk_layer_backed_view&quot; width=&quot;363&quot; height=&quot;162&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_view_backed_node.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41904&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_view_backed_node.png&quot; alt=&quot;asdk_view_backed_node&quot; width=&quot;605&quot; height=&quot;165&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&amp;gt;CALayer 相同的方式，实现了 ASNode-&amp;gt;UIView 这样一个关系。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_node.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41905&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_node.png&quot; alt=&quot;asdk_layer_backed_node&quot; width=&quot;605&quot; height=&quot;167&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;44&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的图层预合成&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_comoose_1.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41906&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_comoose_1.png&quot; alt=&quot;asdk_comoose_1&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_compose_2.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41907&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_compose_2.png&quot; alt=&quot;asdk_compose_2&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;45&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 异步并发操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_a9_chip.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-41908&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_a9_chip.jpg&quot; alt=&quot;asdk_a9_chip&quot; width=&quot;313&quot; height=&quot;176&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;46&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;Runloop 任务分发&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章&lt;a href=&quot;https://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot;&gt; 深入理解RunLoop&lt;/a&gt;，里面对 ASDK 也有所提及。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_runloop.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41909&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_runloop.png&quot; alt=&quot;ios_vsync_runloop&quot; width=&quot;564&quot; height=&quot;234&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m&quot; target=&quot;_blank&quot;&gt;ASAsyncTransactionGroup&lt;/a&gt;。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;微博 Demo 性能优化技巧&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;51&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;预排版&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：&lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/&quot; target=&quot;_blank&quot;&gt;FDTemplateLayoutCell&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;52&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;预渲染&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;53&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;异步绘制&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：&lt;a href=&quot;https://github.com/ibireme/YYAsyncLayer&quot; target=&quot;_blank&quot;&gt;YYAsyncLayer&lt;/a&gt;。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 &lt;span style=&quot;color: #008000;&quot;&gt;BOOL(^isCancelled)()&lt;/span&gt; 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot; target=&quot;_blank&quot;&gt;VVeboTableViewDemo&lt;/a&gt;。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;54&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;全局并发控制&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_1.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41910&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_1.png&quot; alt=&quot;ios_dispatch_blocked_1&quot; width=&quot;330&quot; height=&quot;609&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_2.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41911&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_2.png&quot; alt=&quot;ios_dispatch_blocked_2&quot; width=&quot;340&quot; height=&quot;445&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/tree/master/examples/SocialAppLayout&quot; target=&quot;_blank&quot;&gt;SocialAppLayout&lt;/a&gt;，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 &lt;a href=&quot;https://github.com/ibireme/YYDispatchQueuePool&quot; target=&quot;_blank&quot;&gt;YYDispatchQueuePool&lt;/a&gt;，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;55&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;更高效的异步图片加载&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;56&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;其他可以改进的地方&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;如何评测界面的流畅度&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&amp;gt; Profile -&amp;gt; 修改代码这样一个流程，优先解决最值得优化的地方。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果你需要一个明确的 FPS 指示器，可以尝试一下 &lt;a href=&quot;https://github.com/kconner/KMCGeigerCounter&quot; target=&quot;_blank&quot;&gt;KMCGeigerCounter&lt;/a&gt;。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1&amp;#215;1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;我自己也写了个简单的 FPS 指示器：&lt;a href=&quot;https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m&quot; target=&quot;_blank&quot;&gt;FPSLabel&lt;/a&gt; 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">这篇文章会非常详细的分析 iOS 界面构建中的各种性能问题以及对应的解决思路，同时给出一个开源的微博列表实现，通过实际的代码展示如何构建流畅的交互。</summary></entry><entry><title type="html">小狐狸和小兔子的故事</title><link href="http://localhost:4000/2018/05/21/xiao-tu-zi-xiao-hu-li/" rel="alternate" type="text/html" title="小狐狸和小兔子的故事" /><published>2018-05-21T00:00:00+08:00</published><updated>2018-05-21T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/21/xiao-tu-zi-xiao-hu-li</id><content type="html" xml:base="http://localhost:4000/2018/05/21/xiao-tu-zi-xiao-hu-li/">&lt;blockquote&gt;
  &lt;p&gt;这里是一只小狐狸和小兔子的故事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸偷偷喜欢上了一只小兔子。他每天傍晚都要跑到一个无人的山谷大喊一声“小兔子,我喜欢你!”然后山谷里就会传来“我喜欢你”的回音。小狐狸就那么喊了九十九天,等到一百天时他已经决定要放弃了。他最后一次来到山谷大声地几乎是绝望地喊道:“我喜欢你”。“我也喜欢你”, 山谷的某处传来了回应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;入冬了,怕冷的小狐狸去小兔子开的森林杂货铺买了一件温暖牌的毛衣,一条温暖牌的围巾,还有一个温暖牌的水杯。小狐狸待在家里穿着毛衣戴着围巾喝着杯子里的热水，可还是觉得有点冷,“到底还缺些什么呢?”小狐狸想了想那家森林杂货铺还有铺子里那只可爱的小兔子,“大概我还缺一个温暖牌的拥抱。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸总是忍不住偷偷看小兔子,他尤其喜欢看小兔子那双温柔的红眼睛。但小狐狸的偷看实在太明显了,有时本来只是想悄无声息地看一眼的,可不自觉就着了迷变成了紧紧地注视。“干吗总是盯着我看?”小兔子有天假装生气地问。“我哪有？”小狐狸不肯承认。但在说完这句话的第二天,小狐狸就得了红眼病。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最近胡萝卜大丰收。小兔子吃了好多好多胡萝卜,结果把自己吃成了一个小胖子。这天傍晚她和小狐狸一起在森林里散步时,突然像她从前常常做的那样一下子跳到了小狐狸的背上想要小狐狸背着她走。可小狐狸却一下被压倒在了地上,“我是不是该减肥了?”小兔子哭着对小狐狸说,似乎第一次意识到现在的自己究竟有多重,“不是的,”小狐狸趴在地上说,“是我该锻炼身体了。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“小狐狸,如果我和你妈妈同时掉进水里面了,你会先救谁呢?”小兔子问小狐狸。“当然是先救你啊。”小狐狸想都没想就回答。小兔子心里很开心,但表面还是假装生气 地问道:“为什么要先救我呢?那你妈妈该怎么办啊?”“我妈妈才不会和我计较这种傻问题呢。”小狐狸在心里想。被小兔子问了那个“你会先救谁”的问题之后,小狐狸当时虽然不在意,可后来还是去了游泳学校一边学习游泳一边在心里思索着这个问题。在被水呛到了好几次之后小狐狸学会了游泳,可那个问题依旧没有答案。于是有天小狐狸就不再去学游泳了,“还是不会游泳的好,”小狐狸心想,“这样如果我妈妈和小兔子都掉河里了,我也跳下去陪它们好了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”小狐狸最喜欢做的事就是吹泡泡糖了。而且最厉害的是它能把泡泡糖吹成不同的形状。“你能吹出一个胡萝卜来吗?”小兔子有天对小狐狸说。“当然!”小狐狸脑海中想象着胡萝卜的样子然后就把泡泡吹了出来。果然是一根胡萝卜的形状。“小狐狸,你简直是个魔法师!”小兔子尖叫道, “那你能吹出一个和我长得一模一样的泡泡来吗?”小兔子问。“这有什么难的?”小狐狸一边看着小兔子一边吹起了泡泡糖。可它吹出来的泡泡却是一颗心的模样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”我能亲亲你吗?”小狐狸问身边正在吃爆米花的小兔子。“嗯……”小兔子歪着脑袋想了想,“我们一人吃一口爆米花吧,如果这袋爆米花最后一个是你吃到的我就让你亲我。”小兔子说。结果是小兔子吃到了最后一个。小狐狸沮丧地低下了头,小兔子却迅速亲了一下他的脸庞。“如果是我吃到,就换我来亲你。”小兔子补充道。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;天空突然下起了大雨,小兔子被困在了一株大蘑菇底下。过了一会儿来了一只可爱的小松鼠,他看到在大蘑菇下面避雨的小兔子就问她:“我送你回家好吗?”“谢谢你小松鼠,不过我正在等人呢。”小兔子说。“那我把我的这把伞给你好了。”小松鼠说。“不用了,我想我不需要雨伞。”小兔子说。于是小松鼠有些失望地走了。过了好大一会儿小狐狸从大雨中冲了过来,“大笨蛋,你的伞呢?”小兔子看着浑身湿透的小狐狸心疼地问道。“我不是来给你送伞的,”小狐狸对小兔子说,“我是来陪你一起淋雨的。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“小兔子,感到快乐的时候你最喜欢做什么呢?”“当然是跳舞啦。”“那感到悲伤的时候呢?”“嗯……也会跳舞吧。”“为什么快乐和悲伤的时候都要跳舞呢?”“因为无论是快乐或悲伤都是舞蹈时的一种舞步吧。”…………自从认识了小兔子之后,小狐狸每次一个人走路时,总是忍不住会一边想着小兔子一边在嘴边哼着一首又一首他都不知道是从哪里听来的歌儿。可能是因为小兔子,也可能是因为这些歌曲,小狐狸觉得他走过的每一步都成了舞步。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子看到小狐狸正在愁眉苦脸地吃着一根胡萝卜,“你今天怎么啦?”小兔子觉得有些奇怪,“你不是最讨厌吃胡萝卜了吗?”“可是你喜欢啊,”小狐狸说,“你喜欢的东西我也都想喜欢。”小兔子微微一愣,然后不由得微笑了起来。“那你知道你最应该喜欢的东西是什么吗?”小兔子问。“是什么?”“是你自己呀。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸从小到大从未曾对什么事物感到恐怖过。它不怕狮子老虎大象鳄鱼,当然也不怕流传在森林里的各种恐怖传说。但小狐狸却很想感受一下恐惧究竟是一种什么样的感觉。 为了让小狐狸的愿望达成,小兔子开始每天晚上给小狐狸讲一个鬼故事。可整整一个月了,小狐狸每次听故事时总是一副不为所动的样子,脸上没有丝毫恐惧的表情。小兔子气馁极了。“我不讲啦!”有天小兔子忍不住说道。终于解脱了, 小狐狸心想。可小狐狸刚转身准备要走,小兔子又突然生气地说了一句:“什么都不害怕,你根本就是个冷血动物!”小狐狸迈起的脚步突然停下了,它缓缓地转过身子,眼睛有些失神地看着小兔子,“我想我刚刚知道什么是恐惧了。”小狐狸说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸一边在小溪边钓着鱼一边想着和小兔子有关的事,不知不觉就入了迷。天已经黑了他还没有收拾起鱼竿回家睡觉。小兔子晚上恰巧也睡不着觉,一个人出门散步不知不觉就走到了小溪边。小兔子看到了小狐狸便走向前拍了一下他的肩膀。小狐狸从幻想中惊醒,有些慌张地回头看了看小兔子。然后好像自己的秘密被人揭穿了似的,他把视线慌忙地从小兔子明亮的眼睛上移开。“这么晚了你怎么还不回家?”小兔子的声音从身后传来。“我,我,”小狐狸一时不知该怎么回答,过了一会儿他才看着映满星光的河面说道,“我正在钓星星呢。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子和小狐狸大吵了一架。小兔子发誓以后再也不要和小狐狸说话了。可第二天小狐狸还是忍不住想要去找小兔子。在去小兔子家的路上小狐狸遇到了一只正在爬树的母猪,小狐狸问她:“你为什么要在这里爬树啊?你难道不知道你永远都爬不上吗?” 那只母猪看了看小狐狸,然后嗤嗤地笑了起来,过了一会儿,她忍住笑似的对小狐狸说:“你还说我呢,你不也正去找一个永远都不肯再见你的人吗?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子不肯见小狐狸,小狐狸晚上睡不着觉,就坐在草地上对着漫天的萤火虫诉说自己的心事。“答应我,你们可不能把我刚才说的话讲给别人听。”小狐狸对萤火虫们吩咐道,然后起身回家去了。小狐狸刚刚离开小兔子也跑到了这片草地上。 “刚刚那个说话的影子是小狐狸吗?”小兔子问萤火虫。“是啊,是啊。”萤火虫们回答。“那你们可以告诉我刚刚小狐狸都说了什么吗?”小兔子问。“不可以,不可以,”萤火虫们说,“我们答应过小狐狸的。”小兔子有些难过地低下了头。萤火虫们平时最喜欢小兔子了,看到她沮丧的样子心中都有些不忍。“不过我们虽然答应过小狐狸不说给别人听,”一只萤火虫说道,“可不代表我们不可以用别的方式告诉小兔子啊。”“对啊对啊。”其余的萤火虫附和道。萤火虫们交头接耳地商量了一会儿,突然开始在空中迅速而有序地飞舞起来,不大一会儿,几百只萤火虫用自己身上的荧光一点一点在黑夜中组成了一行闪着光的字。小兔子抬头看去,那行光字写的是:小狐狸说他很想你。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;森林里有一棵很老很老的古树,大树的树身被岁月掏出了一个巨大的树洞。森林里的小动物们习惯把自己的秘密对着树洞说出来。那天小兔子来到了大树下。“其实我也不是那么讨厌小狐狸,”小兔子对着树洞自言自语道,“虽然有时我喜欢凶他,挑他的毛病,无缘无故地不理他,但其实我是有一点点喜欢他的,”小兔子摇了摇脑袋,继续说道,“上次发脾气是我不对,如果小狐狸能在这里就好了,我有点想他了。” 小兔子边说边轻轻地叹息了一声。 “我在。”突然有一个低低的声音从树洞里传来。 小狐狸从漆黑的树洞里钻了出来,“对不起,我不是故意偷听的。”小狐狸解释道,把手里的皮球朝小兔子举了举,“我的皮球不小心踢进树洞里了,我是来捡皮球的。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从前小兔子还在森林杂货铺打工时,小狐狸为了接近她几乎每天都要跑去森林杂货铺买一包水果硬糖。结果一个月下来小狐狸的牙便开始疼了起来。为了让小狐狸的牙疼快快消除,小兔子去山里采了好多草药熬汤给它喝。可小狐狸却总是趁小兔子不注意的时候把碗里的药汤偷偷倒掉。因为他想一直这样牙疼下去,它想让小兔子一直陪在自己身边。“你为什么要把药倒掉?”有天小兔子发现后生气地责问小狐狸, “因为我怕……”小狐狸支支吾吾地说,“因为我怕苦。”“那你就不怕牙疼吗?”小兔子问。可是小狐狸当然不怕牙疼。对小狐狸来说,牙疼只是甜蜜的同义词。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸和小兔子一人提着一大袋零食,散着步走去森林电影院去看一部新上映的关于永恒的爱情电影。电影开场前的一分钟,小兔子问小狐狸他会不会永远爱自己。小狐狸想了想说,他不知道永远是什么。然后他拿起装满零食的袋子对小兔子说:“但我会爱你直至这个塑料袋自行降解。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;夏日的夜晚,小兔子和小狐狸躺在一片林中空地上一起看星星。“小狐狸,你说天上的星星究竟有多少颗呢?”一阵凉风吹过时小兔子问小狐狸。“嗯……”小狐狸想了想, 然后说:“我最多的一次是数1314 颗就睡着了,所以我 不知道天上的星星究竟有多少颗。但我知道地上的星星有多少……”小狐狸转过身看着小兔子明亮的大眼睛说,“地上的星星只有两颗。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸已经就快成年了,根据狐狸家族的传统,每只小狐狸为了迎接自己的成年礼都需要深入到森林的腹地进行一次探险。每只小狐狸只有在这场充满了危险与艰难的探险中找到属于自己的生命的意义才能合格地通过成年礼的考验。 那天小狐狸告别小兔子开始了他的旅程。整整三个月的时间里小狐狸的足迹几乎踏过了森林里的每一片土地,他经历了一次又一次险情,也结交了许许多多的新朋友。但生命的意义对于小狐狸来说仍然是一片茫然。直到三个月后他重新站到小兔子的房子前面,直到小兔子从房子里走了出来站在家门口一动不动地看着他时,小狐狸才终于明白了这场跋涉的意义,他在心里悄悄对小兔子说:原来逛遍了整片森林,只是为了再次回到你家门前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸仰躺在草地上看着天空中的云朵。天空中那些白色的云朵对小狐狸来说只分两种:像小兔子的和不像小兔子的。刚刚开始看时自然是不像小兔子的云朵较多,可看着看着小狐狸就几乎能够在每一片云朵上都找到小兔子的影子了。天色渐晚,等小狐狸起身回家时,天空中已布满了小兔子。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;森林小学这个星期的作文题目是《我最爱的××》, 小老虎写了《我最爱的森林》得了最高分,九十九分,小浣熊写了《我最爱的老师》,得了八十五分,小狐狸写的《我最爱的小兔子》却因为涉及早恋老师只给了十分。“对不起,” 放学后小狐狸对小兔子说,“我对你的爱才得了十分。”“那是因为你十分爱我啊。”小兔子微笑着说。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;转载&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">这里是一只小狐狸和小兔子的故事</summary></entry><entry><title type="html">睡前小故事二-下篇</title><link href="http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia/" rel="alternate" type="text/html" title="睡前小故事二-下篇" /><published>2018-05-18T00:00:00+08:00</published><updated>2018-05-18T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia</id><content type="html" xml:base="http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia/">&lt;blockquote&gt;
  &lt;p&gt;接上篇&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;猫太太是一只不一样的猫&lt;/p&gt;

&lt;p&gt;她不爱吃鱼&lt;/p&gt;

&lt;p&gt;却偏爱吃水果&lt;/p&gt;

&lt;p&gt;可这鬼天气持续了很久&lt;/p&gt;

&lt;p&gt;尽管他们存储了足够多的鱼肉，腊肉&lt;/p&gt;

&lt;p&gt;但是新鲜的水果却不能存储太多&lt;/p&gt;

&lt;p&gt;猫先生吃喝完毕&lt;/p&gt;

&lt;p&gt;从自己的百宝箱中替猫太太找出了一罐水果罐头&lt;/p&gt;

&lt;p&gt;这才让猫太太的脸上露出了笑容&lt;/p&gt;

&lt;p&gt;吃完饭猫先生告诉猫太太&lt;/p&gt;

&lt;p&gt;他们的屋子里取暖的木材不多了&lt;/p&gt;

&lt;p&gt;他要去买一些木材&lt;/p&gt;

&lt;p&gt;说着就穿上风衣带上墨镜踏入了风雪&lt;/p&gt;

&lt;p&gt;猫太太担忧的站在窗边&lt;/p&gt;

&lt;p&gt;看着猫先生走向远方&lt;/p&gt;

&lt;p&gt;也越来越深&lt;/p&gt;

&lt;p&gt;猫先生还没有回来&lt;/p&gt;

&lt;p&gt;猫太太把做好的炒肉热了一遍又一遍&lt;/p&gt;

&lt;p&gt;也不见猫先生回来&lt;/p&gt;

&lt;p&gt;猫太太又生气了&lt;/p&gt;

&lt;p&gt;他就不知道早点回家吗&lt;/p&gt;

&lt;p&gt;不能早点回来也不知道提前打个招呼吗&lt;/p&gt;

&lt;p&gt;嘎吱&lt;/p&gt;

&lt;p&gt;门响了&lt;/p&gt;

&lt;p&gt;从门里滚进来一个圆滚滚的雪球&lt;/p&gt;

&lt;p&gt;还没等到猫太太尖叫&lt;/p&gt;

&lt;p&gt;这个雪球就滚掉了身上一层一层的雪花&lt;/p&gt;

&lt;p&gt;变成了一个冻得冰冰的猫先生&lt;/p&gt;

&lt;p&gt;猫太太忘记了生气&lt;/p&gt;

&lt;p&gt;开心的扑倒在了猫先生的身上&lt;/p&gt;

&lt;p&gt;两只喵打成了一个滚&lt;/p&gt;

&lt;p&gt;猫先生等他闹够了&lt;/p&gt;

&lt;p&gt;神秘兮兮的把她拉到屋后&lt;/p&gt;

&lt;p&gt;哇&lt;/p&gt;

&lt;p&gt;猫太太发誓她从来没有见到过这么多的苹果和梨&lt;/p&gt;

&lt;p&gt;他虽然抱怨着猫先生乱花钱&lt;/p&gt;

&lt;p&gt;可依旧开心的吃着新鲜的水果&lt;/p&gt;

&lt;p&gt;这段时间她馋坏了&lt;/p&gt;

&lt;p&gt;猫先生考虑的很周到&lt;/p&gt;

&lt;p&gt;他原本就计划好&lt;/p&gt;

&lt;p&gt;把这些水果都做成冻梨冻苹果&lt;/p&gt;

&lt;p&gt;这个冬天&lt;/p&gt;

&lt;p&gt;猫小姐体会到了她从未缺少过的甜蜜&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ending&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">接上篇</summary></entry><entry><title type="html">睡前小故事二-上篇</title><link href="http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er/" rel="alternate" type="text/html" title="睡前小故事二-上篇" /><published>2018-05-16T00:00:00+08:00</published><updated>2018-05-16T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er</id><content type="html" xml:base="http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er/">&lt;blockquote&gt;
  &lt;p&gt;今天讲的是猫先生和猫太太的故事，有猫先生和猫太太，那猫孩子哪。筒子们，今天的重点是猫先生和猫太太…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;天空中飘着大雪&lt;/p&gt;

&lt;p&gt;银白的雪伟大地覆盖了一层冰沙&lt;/p&gt;

&lt;p&gt;在这一望无垠的原野上有一座砖瓦小屋&lt;/p&gt;

&lt;p&gt;矮小的它在猫先生看来就是一座城堡&lt;/p&gt;

&lt;p&gt;再豪华的宅院他也不会去换&lt;/p&gt;

&lt;p&gt;为什么？&lt;/p&gt;

&lt;p&gt;猫先生可能要哈哈大笑了：这里是这片原野上唯一可以取暖的地方&lt;/p&gt;

&lt;p&gt;别的地方再好他也难以拥有这种唯一的重要性&lt;/p&gt;

&lt;p&gt;屋里的壁炉燃烧着熊熊的火焰🔥&lt;/p&gt;

&lt;p&gt;刚睡醒的猫先生伸了个懒腰&lt;/p&gt;

&lt;p&gt;在这种任谁也不会出门的天气&lt;/p&gt;

&lt;p&gt;睡了一天的猫先生还想再多睡一会&lt;/p&gt;

&lt;p&gt;可不行了&lt;/p&gt;

&lt;p&gt;猫太太已经炖好鱼汤了&lt;/p&gt;

&lt;p&gt;猫先生身上的懒虫万万及不上那根馋虫&lt;/p&gt;

&lt;p&gt;所以猫先生起床刷完牙&lt;/p&gt;

&lt;p&gt;舔了舔自己的爪子上了餐桌&lt;/p&gt;

&lt;p&gt;做好饭的猫太太看起来有些生气&lt;/p&gt;

&lt;p&gt;猫先生笑了笑没有说话&lt;/p&gt;

&lt;p&gt;在他邀请猫太太一起用餐无果后&lt;/p&gt;

&lt;p&gt;一个人率先吃喝起来&lt;/p&gt;

&lt;p&gt;猫太太就坐在对面冷冷的盯着他&lt;/p&gt;

&lt;p&gt;在猫先生看向他的时候&lt;/p&gt;

&lt;p&gt;又把目光投向别处&lt;/p&gt;

&lt;p&gt;猫先生见状依旧笑了笑没有说话&lt;/p&gt;

&lt;p&gt;他心里很明白&lt;/p&gt;

&lt;p&gt;猫太太为什么不开心&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;未完待续&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">今天讲的是猫先生和猫太太的故事，有猫先生和猫太太，那猫孩子哪。筒子们，今天的重点是猫先生和猫太太…</summary></entry><entry><title type="html">睡前小故事一则</title><link href="http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi/" rel="alternate" type="text/html" title="睡前小故事一则" /><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi</id><content type="html" xml:base="http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi/">&lt;blockquote&gt;
  &lt;p&gt;今天的故事背景是在大海里,讲述一只小海豚和一只大黑鲨的故事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在波澜壮阔的大海里&lt;/p&gt;

&lt;p&gt;生长着无数活泼可爱的小生灵&lt;/p&gt;

&lt;p&gt;其中有一只小海豚尤其可爱&lt;/p&gt;

&lt;p&gt;它活泼又聪明&lt;/p&gt;

&lt;p&gt;美丽又善良&lt;/p&gt;

&lt;p&gt;可惜他却有一个对手&lt;/p&gt;

&lt;p&gt;那就是生长在离她不远海域里的大黑鲨&lt;/p&gt;

&lt;p&gt;说到这只大黑鲨&lt;/p&gt;

&lt;p&gt;小海豚每次都要叹口气&lt;/p&gt;

&lt;p&gt;他们认识了好长时间&lt;/p&gt;

&lt;p&gt;一起玩耍一起学习&lt;/p&gt;

&lt;p&gt;一块逃课打架&lt;/p&gt;

&lt;p&gt;但大黑鲨生性内敛&lt;/p&gt;

&lt;p&gt;虽然在一起相处了好多年&lt;/p&gt;

&lt;p&gt;但却谈不上熟悉&lt;/p&gt;

&lt;p&gt;本来这只大黑鲨虽然有些沉闷&lt;/p&gt;

&lt;p&gt;但生性还算善良&lt;/p&gt;

&lt;p&gt;可随着他们相处的日子变长&lt;/p&gt;

&lt;p&gt;他变得越来越凶恶&lt;/p&gt;

&lt;p&gt;虽然没有对她做什么坏事&lt;/p&gt;

&lt;p&gt;可时常骚扰过往的路人&lt;/p&gt;

&lt;p&gt;从一开始吓唬到他们&lt;/p&gt;

&lt;p&gt;到后来掀翻渔人的小船&lt;/p&gt;

&lt;p&gt;要不是海豚🐬跑的快&lt;/p&gt;

&lt;p&gt;大黑鲨怕是要吃人了&lt;/p&gt;

&lt;p&gt;小海豚劝告了他无数次&lt;/p&gt;

&lt;p&gt;可他都是讷讷的不说话&lt;/p&gt;

&lt;p&gt;所以这片海域&lt;/p&gt;

&lt;p&gt;一直上演着一个追一个救的闹剧&lt;/p&gt;

&lt;p&gt;后来有一天&lt;/p&gt;

&lt;p&gt;大黑鲨出事了&lt;/p&gt;

&lt;p&gt;周围的渔人联合起来抓住了这只大黑鲨&lt;/p&gt;

&lt;p&gt;想要杀他求平安&lt;/p&gt;

&lt;p&gt;善良的小海豚于心不忍&lt;/p&gt;

&lt;p&gt;跑去百般求饶&lt;/p&gt;

&lt;p&gt;最后渔人们看在他的救命之恩的份上&lt;/p&gt;

&lt;p&gt;答应给这只鲨鱼一次机会&lt;/p&gt;

&lt;p&gt;渔人们远去后&lt;/p&gt;

&lt;p&gt;海豚望着吓得面如土色的鲨鱼&lt;/p&gt;

&lt;p&gt;叹了口气&lt;/p&gt;

&lt;p&gt;终于忍不住问&lt;/p&gt;

&lt;p&gt;你为什么非要伤害别人哪&lt;/p&gt;

&lt;p&gt;讷讷的鲨鱼可能被吓傻了&lt;/p&gt;

&lt;p&gt;想也没想&lt;/p&gt;

&lt;p&gt;说道：还不是为了引起你的注意&lt;/p&gt;

&lt;p&gt;小海豚万万没想到这个答案&lt;/p&gt;

&lt;p&gt;又羞又气&lt;/p&gt;

&lt;p&gt;问：那你为什么不直接来找我而要去找别人的麻烦&lt;/p&gt;

&lt;p&gt;大黑鲨好像开了窍：因为我会害羞&lt;/p&gt;

&lt;p&gt;海豚扑哧一声笑了&lt;/p&gt;

&lt;p&gt;他什么都没说&lt;/p&gt;

&lt;p&gt;拉着黑鲨的鳍游向了广阔的远方&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">今天的故事背景是在大海里,讲述一只小海豚和一只大黑鲨的故事</summary></entry><entry><title type="html">思维游戏</title><link href="http://localhost:4000/2018/05/13/si-wei-you-xi/" rel="alternate" type="text/html" title="思维游戏" /><published>2018-05-13T00:00:00+08:00</published><updated>2018-05-13T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/13/si-wei-you-xi</id><content type="html" xml:base="http://localhost:4000/2018/05/13/si-wei-you-xi/">&lt;blockquote&gt;
  &lt;p&gt;这里讲述了无聊闲暇时候的天马星空，忘记摘抄自哪里了，感觉和自己的某些时候真的好像，相信大家也经历过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在从前那些没有手机游戏和电子书的日子里。我在漫长的旅途中只能靠思维游戏打发时间。&lt;/p&gt;

&lt;p&gt;所谓”思维游戏”，是我给自己的胡思乱想起的学名。这种游戏很简单，先设想一个原点——我突然得到了十亿美元，突然得到了校花的青睐，突然写出一部震惊古今的小说——然后开始想象我接下来采取的行动。后来年纪大了，我知道这种东西有一个通俗的说法，叫做意淫。&lt;/p&gt;

&lt;p&gt;我最喜欢的一个命题，是”如果我在沙漠中间发现一整块十吨重的黄金，该怎么办？”。通常的想法是，我靠我可发财了。但其实从这个命题到真正发财，还有一段距离。你要如何把黄金真正转换成自己的私有财富？这种想象要尽可能细致，细致到每一个动作，要考虑到每一个可能产生的意外。你会发现，事情没想象中那么简单。首先这十吨黄金你要如何运输出去？要不要找人？怎么保密？如何分成？如果你决心单干，那还要想租用哪些设备和车辆，如何在沙漠中一个人把十吨黄金切割成可运输大小。返回城镇以后，你如何卸货，如何存放？如何遮人耳目？接下来黄金你要如何处理？一古脑卖出去会造成市场波动，被国家觉察，私下分批次处理如何操作？怎么找买家？钱是分开存在哪家银行？怎么避开税务部门？如何跟家里人解释突然有这么一大笔钱？哪些亲戚和朋友要告诉哪些要保密……其实是件很复杂的事，规划起来很花功夫。这个思维游戏我已经玩了好多年，现在已经有了一整套详尽的计划，而且随时根据现实科技发展来调整，万事俱备，只欠真的发现十吨黄金了。&lt;/p&gt;

&lt;p&gt;除此以外，还可以琢磨人。我坐地铁的时候，经常人多拥挤不堪，不光没有座位，连伸开手臂拿手机或PSP的空间都没有。在这种情况之下，唯一能动的，只有脑子。我会仔细观察周围的人，幻想他们身上隐藏的故事和他们离开地铁以后的人生。&lt;/p&gt;

&lt;p&gt;比如右边那位衣着朴素、身形瘦小的大叔。也许他离开地铁以后，找到一个没人的地方换上紧身衣，把内裤套在头上，然后飞过整个城市，在大街小巷除暴安良。&lt;/p&gt;

&lt;p&gt;再比如左边这位戴着棒球帽、穿着阿迪达斯运动套装的白皙少年。他是一个外星人，为了能够深入了解地球人的生活，特意化装成，他也许已经完成了自己的使命，正踏上返回母星的旅程，可因为棒球队那个美丽的女经理殷切的眼神，他还是毅然决然地留在了地球。&lt;/p&gt;

&lt;p&gt;而我们坐的这部地铁，谁又能保证它下一站抵达的是普通地铁站而不是这个城市底下巨大的军事要塞呢。在要塞里有一门利用灵魂作炮弹的大炮，炮口对准月球。每一个不幸的地铁乘客都要被送进炮口，把灵魂贡献出来去轰击月球上的兔子恶魔。&lt;/p&gt;

&lt;p&gt;甚至这部地铁本身，或许并不是地铁，而是一条龙。它偶尔坠落到了地面，被捡到的科学家改造成了一节地铁，每天都在暗无天日的隧道里穿行，把乘客们从城市的一端运往另外一端，没有一天休息。只有在晚上十一点地铁停运之后，这条龙才能停下疲惫的身躯，从隧道的洞口爬出去，昂起头来看一眼暌违已久的天空。&lt;/p&gt;

&lt;p&gt;我就这么坐在地铁里，在城市的腹心穿行，眼睛看着乘客，脑子里琢磨着他们的种种不靠谱故事，一直到达我旅途的终点。&lt;/p&gt;

&lt;p&gt;这种”思维游戏”有一个分支种类，叫做”想象图书”。玩的时候，我会闭上眼睛。开始虚构一本从来没存在的书，想象它的主题、内容简介、封面图案、名家书评、作者的创作意图和轶事，尽量煞有其事地补充除了内容以外的各类细节，使之丰满如真实存在一般，然后把它放到我想象中的书架上去。以后再碰到无聊的时候，我就信手抽出一本，靠回忆来阅读。&lt;/p&gt;

&lt;p&gt;比如我曾幻想路遥在写《平凡的世界》时，在稿纸背面写下了另外一个故事。故事的主角是落水的田晓霞，她死里逃生却遭遇失忆，被人救起以后开始了另外一段人生。几十年后她和孙少平在街头偶遇，擦肩而过，互不相识。可惜的是，这份稿纸被编辑忽略了，一直丢在存稿箱中。直到几年后路遥去世，一个新毕业的编辑打算准备纪念专题，无意中把存稿箱打翻在地，这才发现稿纸背面的秘密。不过老编辑认为这个故事会损害《平凡的世界》的形象，于是只印制了一千册，赠送给路遥的亲朋好友，书的封面是个巨大的漩涡。其中一本，不知如何流落到了桂林临桂中学，扉页还盖有临桂中学图书室藏的红章。里面的借书卡里只有一条借阅记录，是个女孩借走的。她比我大一届，喜欢穿米黄色的毛衣，宿舍里的台灯用粉红色的纸罩着&lt;/p&gt;

&lt;p&gt;我书架上的另外一本书，叫做《廷巴克图故事集》。在1822年，英国组织了一支探险队，从的黎波里出发，计划南穿撒哈拉沙漠，寻找尼日尔河与尼罗河的源头。探险队中有一名人类学家，叫做塞缪尔·欧内斯特，他抵达廷巴克图之后，注意到当地图阿雷格人部族存在着一种奇特的风俗：酋长在死后会被部落巫师敲破脑壳，接出脑浆，掺杂着蜂蜜和椰汁给被选中的孩童服用。那个孩子就会流利地背诵出一段故事，然后一生都无法发出声音。这些故事巧妙而有寓意，被认为是神的意旨，所以不允许被记录下来。于是欧内斯特花了十三年时间，等待每一个类似的仪式，偷偷记下了几十个故事。可惜他的行为最终被土著人发现，惨遭杀害。他死后，脑浆也被土著人用同样的方式制成饮料，盛放在他生前用过的水壶里。&lt;/p&gt;

&lt;p&gt;后来该部落被殖民者屠戮一空，这个水壶与记录手稿被送回葡萄牙，作为遗物交还给欧内斯特的遗孀。这份手稿一直沉睡在旧物箱里。直到有一天欧内斯特的孙子无意中打开水壶，喝下他爷爷的脑浆，当着家人的面高声说出这些手稿的来历。欧内斯特的工作才公之于世。手稿于1923年结集出版，命名为《廷巴克图故事集》，版税用来为欧内斯特的孙子治疗哑病。该书的第一版中文版在1973年的台湾出版，但销路不佳，名人里只有邓丽君买过一本，并遗落在雅加达的旅馆里……&lt;/p&gt;

&lt;p&gt;这样编下去的话，简直没完没了，可以从一本书想象到一个家族史乃至国家史。在构思这些东西的时候，时间会如风车一样过得飞快。等车抵达终点，我所获得的愉悦感,和看一本书差不多。&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">这里讲述了无聊闲暇时候的天马星空，忘记摘抄自哪里了，感觉和自己的某些时候真的好像，相信大家也经历过</summary></entry><entry><title type="html">眼中的自己</title><link href="http://localhost:4000/2018/05/11/myself/" rel="alternate" type="text/html" title="眼中的自己" /><published>2018-05-11T00:00:00+08:00</published><updated>2018-05-11T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/11/myself</id><content type="html" xml:base="http://localhost:4000/2018/05/11/myself/">&lt;blockquote&gt;
  &lt;p&gt;人的一生最大的敌人是自己，最难看清的也是自己。&lt;/p&gt;

  &lt;p&gt;借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可以信任&lt;/p&gt;

    &lt;p&gt;一般来讲，一件事情如果我应下来，那就会尽力去朝着想要的结果而努力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;热爱阅读&lt;/p&gt;

    &lt;p&gt;不管有用的没用的，我总是在阅读着，也在进行着一些相应的思考。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;拖延症&lt;/p&gt;

    &lt;p&gt;任由事情在自己手上堆积，找各种借口不去开始，即使那件事情只需要两分钟就能处理完。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;必须症&lt;/p&gt;

    &lt;p&gt;对自己身上客观存在的一些东西没有无条件地接受；对别人的行为和这个世界的样子存在期待，一旦不符合期待便会焦虑和自我挫败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;含糊症&lt;/p&gt;

    &lt;p&gt;别人来问我什么问题的时候总是回答得很快，有时候给出的并不是经过思考后最合理最确定的回答，后来反应和发觉过来只好再去补救。其实别人没那么急，略等几秒在脑海里找到确定的答案再答复相对是效率更高的方式，这并不会显得我没有准备和欠思考，实际上它比我立即给出一个不准确的答案而后来再推翻或补充要好。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">人的一生最大的敌人是自己，最难看清的也是自己。 借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。</summary></entry><entry><title type="html">私有库创建</title><link href="http://localhost:4000/2018/05/06/podSpec/" rel="alternate" type="text/html" title="私有库创建" /><published>2018-05-06T00:00:00+08:00</published><updated>2018-05-06T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/06/podSpec</id><content type="html" xml:base="http://localhost:4000/2018/05/06/podSpec/">&lt;blockquote&gt;
  &lt;p&gt;cocoaPods 公有库和私有库的创建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;cocoapodspods-公有库创建&quot;&gt;cocoapodsPods 公有库创建&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;pod lib create KKLPush&lt;/li&gt;
  &lt;li&gt;添加文件到 classes中&lt;/li&gt;
  &lt;li&gt;执行 pod install&lt;/li&gt;
  &lt;li&gt;推送到远端&lt;/li&gt;
  &lt;li&gt;添加 tag&lt;/li&gt;
  &lt;li&gt;检查有效性
    &lt;blockquote&gt;
      &lt;p&gt;pod lib lint –allow-warnings&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;pod trunk push –allow-warnings&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;开课啦cocoapods私有库创建教程&quot;&gt;开课啦CocoaPods私有库创建教程&lt;/h1&gt;

&lt;h3 id=&quot;创建私有-spec-repo&quot;&gt;创建私有 Spec Repo&lt;/h3&gt;

&lt;p&gt;先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。&lt;/p&gt;

&lt;p&gt;因此我们需要创建一个类似于master的私有Spec Repo。我们可以创建一个私有的git仓库当做我们自己的Spec Repo。（已经在公司的gitlab上创建好了名叫&lt;a href=&quot;http://git.mistong.com/ios-framework/mistong-repo&quot;&gt;mistong-repo&lt;/a&gt;的私有Spec Repo）&lt;/p&gt;

&lt;p&gt;创建完成之后在Terminal中执行如下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo add mistong ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时如果成功的话进入到~/.cocoapods/repos目录下就可以看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt; 这个目录了。至此我们的pod就能在本地search到 &lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt; 里申明的所有库了。&lt;/p&gt;

&lt;h3 id=&quot;创建cocoapods私有库&quot;&gt;创建CocoaPods私有库&lt;/h3&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.jianshu.com/p/c6c227c0c221&quot;&gt;CocoaPods建立私有仓库 spec repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们来创建一个私有库，以KKLKit为例。&lt;/p&gt;

&lt;p&gt;在Terminal中执行如下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod lib create KKLKit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后他会问你几个问题，1. 选择开发语言 2.是否需要一个例子工程；3.选择一个测试框架；4.是否基于View测试；5.类的前缀；这几个问题的具体介绍可以去看官方文档，我这里选择的是1.ObjC  ;2.Yes；3.None；4.None；4.KKL。 问完这几个问题他会自动执行pod install命令创建项目并生成依赖。&lt;/p&gt;

&lt;p&gt;_Pods.xcodeproj文件在这里并没有什么作用，可以直接删掉。 其中KKLKit目录仅包含了KKLKit的源文件及图片资源等文件，Example目录则包含了KKLKit相关的demo。我们在编写KKLKit的源码的时候，直接在Example的工程中进行。&lt;/p&gt;

&lt;p&gt;现在我们进入Example目录，打开.workspace文件。
可以看到，Development Pods目录下的KKLKit目录就是我们的库源码。可以直接修改该目录下的代码。需要注意的是，如果需要在KKLKit中增加或删除文件，在增加文件后，需要在Example的根目录，执行一下&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install &lt;/code&gt; 命令。&lt;/p&gt;

&lt;h3 id=&quot;发布私有库&quot;&gt;发布私有库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;编辑podspec文件，发布版本库前，需要先配置好podspec文件，具体模板可以参考&lt;a href=&quot;http://git.mistong.com/ios-framework/CKKit/blob/master/CKKit.podspec&quot;&gt;CKKit.podspec&lt;/a&gt;。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#
# Be sure to run `pod lib lint CKKit.podspec' to ensure this is a
# valid spec before submitting.
#
# Any lines starting with a # are optional, but their use is encouraged
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
#
Pod::Spec.new do |s|
s.name             = 'CKKit'
s.version          = '0.1.11'
s.summary          = 'CKKit是一个工具类的库'
# This description is used to generate tags and improve search results.
#   * Think: What does it do? Why did you write it? What is the focus?
#   * Try to keep it short, snappy and to the point.
#   * Write the description between the DESC delimiters below.
#   * Finally, don't worry about the indent, CocoaPods strips it!
s.description      = &amp;lt;&amp;lt;-DESC
CKKit是一个工具类的库，主要包含容器类、通知、数据源相关的管理类及工具类
                     DESC
s.homepage         = 'http://git.mistong.com/ios-framework/CKKit'
# s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'
s.license          = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' }
s.author           = { 'jiangjunchen' =&amp;gt; 'jiangjunchen@kaike.la' }
s.source           = { :git =&amp;gt; 'ssh://git@git.mistong.com:10022/ios-framework/CKKit.git', :tag =&amp;gt; s.version.to_s }
# s.social_media_url = 'https://twitter.com/&amp;lt;TWITTER_USERNAME&amp;gt;'
# s.module_map = 'CKKit/CKKit.modulemap'
s.ios.deployment_target = '8.0'
s.source_files = 'CKKit/Classes/CKKit.h'
s.subspec 'Base' do |ss|
    ss.source_files = 'CKKit/Classes/Base/**/*'
end
s.subspec 'UIKit' do |ss|
    ss.source_files = 'CKKit/Classes/UIKit/**/*'
    ss.dependency 'CKKit/Base'
end
# s.source_files = 'CKKit/Classes/**/*'
# s.resource_bundles = {
#   'CKKit' =&amp;gt; ['CKKit/Assets/*.png']
# }
# s.public_header_files = 'Pod/Classes/**/*.h'
# s.frameworks = 'UIKit', 'MapKit'
# s.dependency 'AFNetworking', '~&amp;gt; 2.3'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传后保存会有目录结构&lt;br /&gt;
&lt;img src=&quot;http://note.youdao.com/yws/res/1892/WEBRESOURCEba18671e1fe66bf403fecade8204e488&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;git commit后，需要打tag，并push到远程。如&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;first release&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt; 
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;nt&quot;&gt;--tags&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#推送tag到远端仓库&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;验证私有库的正确性&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod lib lint &lt;span class=&quot;nt&quot;&gt;--allow-warnings&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;验证成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向Spec Repo提交podspec。 向我们的私有Spec Repo提交podspec只需要一个命令&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo push mistong ./KKLKit.podspec &lt;span class=&quot;nt&quot;&gt;--allow-warnings&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt;就是我们的私有Spec Repo，&lt;code class=&quot;highlighter-rouge&quot;&gt;./KKLKit.podspec&lt;/code&gt;则是我们私有库的描述文件路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;注如果podspec的依赖包含你自己的私有库那么验证命令后面要填写你所依赖的那个私有库的连接地址和cocoapods的默认地址&quot;&gt;注：如果podspec的依赖包含你自己的私有库。那么验证命令后面要填写你所依赖的那个私有库的连接地址和cocoapods的默认地址&lt;/h4&gt;

&lt;p&gt;如：$ pod lib lint –sources=’ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git,https://github.com/CocoaPods/Specs’ –use-libraries –allow-warnings&lt;/p&gt;

&lt;h3 id=&quot;安装私有库&quot;&gt;安装私有库&lt;/h3&gt;

&lt;p&gt;安装私有库需要在Podfile文件顶部申明一下我们的私有Repo Spec地址，以及pod公共的Repo Spec地址。 再在podfile中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'CKKit', '~&amp;gt; 0.0.1'&lt;/code&gt;来申明私有库&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://github.com/CocoaPods/Specs.git'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;关于resources&quot;&gt;&lt;a href=&quot;http://blog.xianqu.org/2015/08/pod-resources/&quot;&gt;关于Resources&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;新版的cocoapods推荐在podspec使用&lt;code class=&quot;highlighter-rouge&quot;&gt;resource_bundle&lt;/code&gt;方式引用资源文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.resource_bundle = {'LibName' =&amp;gt; ['LibName/*.png']}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理论上一个 bundle 里可以有一个 asset catalog。Xcode 最后会把它们编译成 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assets.car&lt;/code&gt; 文件。但是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;resource_bundle&lt;/code&gt;这种方式对&lt;code class=&quot;highlighter-rouge&quot;&gt;Image.xcassets&lt;/code&gt;支持不太好，会出现找不到图片的情况。所以增对图片资源，要么不使用xcassets，直接将图片放到文件目录中；要么使用podspec的resources方式添加图片的xcassets。&lt;/p&gt;

&lt;p&gt;我这里推荐采用resources方式添加图片资源，因为pdf格式的图片需要放到xcassets中才能直接使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.resources = 'XHXUser/Assets/**/*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么在代码中可以用如下方式获取pod库中的图片资源:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSBundle *bundle = [NSBundle bundleForClass:[XHXUserAPI class]];
UIImage *image = [UIImage imageNamed:@&quot;LoginLogo&quot; inBundle:bundle compatibleWithTraitCollection:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你可以在pod库内部创建一个宏&lt;code class=&quot;highlighter-rouge&quot;&gt;ModuleImage&lt;/code&gt;，用于获取私有库内部的图片:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// 根据图片名，获取模块内部的图片
#define ModuleImage(name) [UIImage imageNamed:(name) inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]
&lt;/code&gt;&lt;/pre&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">cocoaPods 公有库和私有库的创建</summary></entry><entry><title type="html">GitPage, apatch</title><link href="http://localhost:4000/2018/05/03/apatch-gitpage/" rel="alternate" type="text/html" title="GitPage, apatch" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/03/apatch-gitpage</id><content type="html" xml:base="http://localhost:4000/2018/05/03/apatch-gitpage/">&lt;blockquote&gt;
  &lt;p&gt;记录一些常见问题的细节备份&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;遇到恼人的权限安装或者删除的权限问题的时候在命令中添加-n-usrlocalbin-即可执行&quot;&gt;遇到恼人的权限安装或者删除的权限问题的时候在命令中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;-n /usr/local/bin&lt;/code&gt; 即可执行&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install -n /usr/local/bin cocoapods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;gitpage-本地调试&quot;&gt;GitPage 本地调试&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//首次本地安装jelly
sudo gem install -n /usr/local/bin jekyll bundler
// 启动本地jeklly 环境
jeklly serve
// 访问
localhost:4000 
//停止jeklly服务
ctrl + c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mac-本地apatch服务开启&quot;&gt;mac 本地Apatch服务开启&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 启动Apache服务
sudo apachectl start
// 重启Apache服务
sudo apachectl restart
// 停止Apache服务
sudo apachectl stop
// 查看Apache版本
httpd -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;step-1&quot;&gt;step 1&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#LoadModule rewrite_module libexec/apache2/mod_rewrite.so
// uncommet this line
LoadModule php7_module libexec/apache2/libphp7.so
#LoadModule perl_module libexec/apache2/mod_perl.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;step-2&quot;&gt;step 2&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#DocumentRoot &quot;/Library/WebServer/Documents&quot;
#&amp;lt;Directory &quot;/Library/WebServer/Documents&quot;&amp;gt;
DocumentRoot &quot;/Users/jason/Sites&quot;
&amp;lt;Directory &quot;/Users/jason/Sites&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;step-3&quot;&gt;step 3&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Options FollowSymLinks Multiviews
 Options Indexes FollowSymLinks Multiviews
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;和谐版的alfred-3-在每次开机后都会提示是否允许访问通讯录的弹窗&quot;&gt;和谐版的Alfred 3 在每次开机后，都会提示“是否允许访问通讯录”的弹窗&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">记录一些常见问题的细节备份</summary></entry><entry><title type="html">Xcode 9 iOS 11适配</title><link href="http://localhost:4000/2018/05/02/ios-11-Xcode/" rel="alternate" type="text/html" title="Xcode 9 iOS 11适配" /><published>2018-05-02T00:00:00+08:00</published><updated>2018-05-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/02/ios-11-Xcode</id><content type="html" xml:base="http://localhost:4000/2018/05/02/ios-11-Xcode/">&lt;blockquote&gt;
  &lt;p&gt;iOS 11, Xcode 9 的一些适配问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&quot;detailbody&quot; class=&quot;field_body&quot;&gt;
                    &lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iOS11发布也有一段时间了，每次版本升级，相关的适配工作当然是下个版本的核心工作之一。而且这次iOS11的更新，相对于iOS10的更新来说，改动点还是比较多的。除了iOS11系统的更新之外，iPhoneX刘海的打理工作也是必不可少。以前我们总是庆幸作为iOS开发者，不必像Android开发者需要考虑各种不同机型的适配问题。但是现在，随着iPhone各种历史版本的存在，各种花式的新版本产生，不同版本之间的适配问题，也是未来我们作为iOS开发者必然要考虑的重要问题之一。&lt;/p&gt;&lt;p&gt;这次我主要负责我们这边两款App(滴滴代驾司机端+驾管App)iOS11&amp;amp;iPhoneX适配工作。中间也躺过很多坑，一一记录了下来写成这篇文章，既是对自己工作的一次总结，也可以分享给其他iOS开发者，能够让大家少趟一些坑。&lt;/p&gt;&lt;p&gt;本文将分为三个部分，分别从三方库适配、UI适配、权限适配、补充知识等方面分别进行展开。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;二、三方库适配问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;2.1 CocoaLumberjack 编译出错&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 12px; color: rgb(127, 127, 127);&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771491256554.png&quot; title=&quot;1521771491256554.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771491256554.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 12px; color: rgb(127, 127, 127);&quot;&gt;CocoaLumberjack编译报错&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从错误提示可以看出在Xcode9中os_log_error的第二个参数format必须要为不可变的string类型，而不是char*。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们只要改成如下形式就可以了&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_584187&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;os_log_error(OS_LOG_DEFAULT,&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 string&quot;&gt;&quot;%s&quot;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;,&amp;nbsp;msg);&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;CocoaLumberjack的作者也在[issue883](&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/Co&quot; target=&quot;_blank&quot; _href=&quot;https://link.jianshu.com/?t=https://github.com/Co&quot;&gt;https://github.com/Co coaLumberjack/CocoaLumberjack/issues/883&lt;/a&gt;)中解决了该问题。如果你的工程是pod依赖的话，将pod版本升级到3.3.0版本即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;2.2 WebViewJavascriptBridge崩溃处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们代驾司机端web容器使用的是WKWebView，jsBridge使用的是WebViewJavascriptBridge这个三方库，更新到Xcode9之后，只要进入WKWebView容器，就会产生如下crash:&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771550751368.png&quot; title=&quot;1521771550751368.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771550751368.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 12px; color: rgb(127, 127, 127);&quot;&gt;WebViewJavascriptBridge crash&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当你使用WKWebView作为你的H5容器的时候，WKNavigationDelegate有个回调就是&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_225402&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;-&amp;nbsp;(&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;void&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)webView:(WKWebView&amp;nbsp;*)webView&amp;nbsp;decidePolicyForNavigationAction:(WKNavigationAction&amp;nbsp;*)navigationAction&amp;nbsp;decisionHandler:(&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;void&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;(^)(WKNavigationActionPolicy))decisionHandler;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;这个回调主要负责根据webView、navigationAction相关信息决定这次跳转是否可以继续进行。调用decisionHandler(WKNavigationActionPolicyAllow);响应这次跳转请求。调用decisionHandler(WKNavigationActionPolicyCancel);就是不响应这次跳转请求。&lt;/p&gt;&lt;p&gt;查看WebViewJavascriptBridge源码可以看出，在WKWebViewJavascriptBridge.m文件中&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771604832877.png&quot; title=&quot;1521771604832877.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771604832877.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 12px; color: rgb(127, 127, 127);&quot;&gt;WKVebViewCrash.png&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在Xcode9中，如果连续看了两次调用decisionHandler方法就会crash。这个问题在之前版本的Xcode均是没有问题的。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;方案一：修改源码&lt;/p&gt;&lt;p&gt;在上面代码的149行和150行之间添加return;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;方案二：pod依赖，原作者没有修改此问题，无法修改源码，也可以在业务代码中进行规避。&lt;/p&gt;&lt;p&gt;在你自己业务代码的对应对调中添加排除代码，如下：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771633371153.png&quot; title=&quot;1521771633371153.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771633371153.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 12px; color: rgb(127, 127, 127);&quot;&gt;WKWebViewCrash2.png&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;2.3 LumberjackConsole UI适配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771742682266.png&quot; title=&quot;1521771742682266.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771742682266.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iOS7之后，如何你设置self.edgesForExtendedLayout = UIRectEdgeNone的话,系统通过设置UIViewController的automaticallyAdjustsScrollViewInsets属性来自动调整UIScrollView的contentInset，使UIscrollView能够呈现在我们的可是范围之内，而不会被navBar挡住。这个属性在iOS11中被废弃掉了，在iOS11中代替该属性功能的则是UIScrollView类中的contentInsetAdjustmentBehavior和adjustedContentInset属性.在iOS11中用来决定scrollView超出安全区域与边缘距离的属性是adjustedContentInset而不是contentInset。当scrollView超出安全区域时系统会自动调整SafeAreaInsets值，进而影&lt;/p&gt;&lt;p&gt;响 adjustedContentInset，所以导致scrollView下移20pt或者64pt。当使用自定义的 navigationbar，并且scrollView的frame超出安全区域，SafeAreaInsets为(20,0,0,0);当使用系统的navigationbar，SafeAreaInsets为(64,0,0,0)。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在UIScrollView或者UITableView初始化的地方，加入如下代码即可。&lt;/p&gt;&lt;p&gt;针对LumberjackConsole这个开源库，我们可以在PTEConsoleTableView.m文件中的commonInit最后加入如下代码即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_459276&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;([self&amp;nbsp;respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]){&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;[self&amp;nbsp;setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentNever];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;三、UI适配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.1 NavBar中右上角的customView产生偏移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771807148487.png&quot; title=&quot;1521771807148487.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771807148487.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在iOS11中，新的导航视图，使用了AutoLayout布局。而我们这边右上角的两个按钮组合成一个customView，然后把这个customView设置给setRightBarButtonItems而来。customView内部都是frame布局，所以在自动布局下面出错。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;NavBar中的customView里面针对iOS11，均要采用自动布局。&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771889744285.png&quot; title=&quot;1521771889744285.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771889744285.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.2 NavBar中自定义TitleView产生偏移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771925217984.png&quot; title=&quot;1521771925217984.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771925217984.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同上&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同上&lt;/p&gt;&lt;p&gt;这里需要注意一点，自动布局的UI是延迟设置frame的。如果aView采用自动布局。然后你马上调用它的aView.bounds是不正确的。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.3 NavBar中按钮的响应区域都变小了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771969320121.png&quot; title=&quot;1521771969320121.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521771969320121.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iOS11之前，虽然我们设置了NavBar上每一个[btn sizeToFit]。苹果依然会帮我们把每一个按钮的点击区域扩大，可以点击区域如上图绿色区域所示。但是在iOS11中，你的按钮的bounds为多大，那你的点击区域就只有多大。估计这个改动也与这次NavBar的大概有关系。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;扩大每一个btn的bounds，而不要使用sizeToFit方法。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.4 NavBar的BarButtonItem无法贴边。有（非plus手机16pt，plus手机20pt）的区域浪费。造成UI偏移，并且最左侧和最右侧区域无法点击。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772008284264.png&quot; title=&quot;1521772008284264.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772008284264.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个UINavigationBarContentView平铺在导航栏中作为iOS11的各个按钮的父视图,该视图的所有的子视图都会有一个layoutMargins被占用,也就是系统调整的占位。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;去掉系统默认占位。&lt;/p&gt;&lt;p&gt;系统并没有提供我们直接去掉系统默认占位的方法，那怎么做呢？&lt;/p&gt;&lt;p&gt;我们新建一个UINavigationBar的分类，hook住UINavigationBar的layoutSubviews方法。然后遍历View，重新设置layoutMargin约束。&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772030450415.png&quot; title=&quot;1521772030450415.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772030450415.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: rgb(127, 127, 127); font-size: 12px;&quot;&gt;重新设置layoutMargin约束&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.5 UITableView 默认开启Self-Sizing，导致UI显示有问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772063265490.png&quot; title=&quot;1521772063265490.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772063265490.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在iOS11中UITableView会默认使 Self-Sizing,这会导致tableView&lt;/p&gt;&lt;p&gt;的 estimatedRowHeight 、 estimatedSectionHeaderHeight 、 estimatedSectionFooterHeight 的高度估算属性由默认的0变成 UITableViewAutomaticDimension ,reloadData时可能会导致最后显示的contentSize与预想的不一致;&lt;/p&gt;&lt;p&gt;同时在iOS11中如果不实现 -tableView: viewForHeaderInSection: 和 tableView: viewForFooterInSection: 方法，则 -tableView: heightForHeaderInSection: 和 - tableView: heightForFooterInSection: 不会被调用，而iOS11之前则没问题。上述都可能会导致界面出现错乱。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;单独关闭摸一个UITableView的Self-Sizing。&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_757318&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;_tableView.estimatedRowHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;.;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;_tableView.estimatedSectionFooterHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;.;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;_tableView.estimatedSectionHeaderHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;.;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;关闭所有的UIScroolView、UITableView和UICollectionView的Self-Sizing：&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_988978&quot; class=&quot;syntaxhighlighter  as3 &quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UIScrollView.appearance.contentInsetAdjustmentBehavior&amp;nbsp;=&amp;nbsp;UIScrollViewContentInsetAdjustmentNever;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UITableView.appearance.estimatedRowHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UITableView.appearance.estimatedSectionFooterHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UITableView.appearance.estimatedSectionHeaderHeight&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.6 keyWindow获取错误, 导致UI问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772110791559.png&quot; title=&quot;1521772110791559.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772110791559.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;机器猫图标是一个UIWindow，windowLevel级别比UIWindowLevelStatusBar还高，所以可以常驻UI最上方。第一次进入该页面，点击“更多”，弹出popView，点击收藏，弹出系统UIAlertView，此时UIAlertView变成了keyWindow。当UIAlertView消失的时候，keyWindow会被谁接管呢？&lt;/p&gt;&lt;p&gt;iOS11之前，弹出UIAlertView之前的keyWindow是[[UIApplication sharedApplication].delegate window]，那么消失的时候，keyWindow还是[[UIApplication sharedApplication].delegate window]。&lt;/p&gt;&lt;p&gt;iOS11, 弹出UIAlertView之前的keyWindow是[[UIApplication sharedApplication].delegate window]，那么消失的时候，keyWindow变成z轴最高的UIWindow，即变成了机器猫那个window。所以导致popView被添加到机器猫window中，造成UI样式问题。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;重写自定义UIWindow的becomeKeyWindow的方法，每次自定义window将会变为keyWindow的时候，把keyWindow改成[[UIApplication sharedApplication].delegate window]。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_215343&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;-&amp;nbsp;(&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;void&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)becomeKeyWindow{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UIWindow&amp;nbsp;*appWindow&amp;nbsp;=&amp;nbsp;[[UIApplication&amp;nbsp;sharedApplication].delegate&amp;nbsp;window];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;[appWindow&amp;nbsp;makeKeyWindow];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;3.7 状态栏高度写死为20pt，导致在iPhoneX上面遮挡住statusBar。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772153502038.png&quot; title=&quot;1521772153502038.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772153502038.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iPhoneX上的statusBar的高度为44pt，跟其他iPhone型号的20pt不一样。所以以后我们在以statusBar为定位点的时候，不能写死20pt。而要使用[UIApplication sharedApplication].statusBarFrame.size.height来获取，为了方便，可以定义为宏，放到pch文件中，如下：&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_793724&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;kApplicationStatusBarHeight&amp;nbsp;&amp;nbsp;[UIApplication&amp;nbsp;sharedApplication].statusBarFrame.size.height&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 comments&quot;&gt;//状态栏的高度&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;状态栏高度定位的时候不要写死20，要使用[UIApplication sharedApplication].statusBarFrame.size.height来获取。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iOS11之前导航栏默认高度为64pt(这里高度指statusBar + NavigationBar)，iOS11之后如果设置 prefersLargeTitles = YES则为96pt，默认情况下还是64pt，但在iPhoneX上由于刘海的出现 statusBar由以前的20pt变成 44pt，所以iPhoneX上高度变为88pt，如果项目里隐藏了导航栏加了自定义按钮之类的，这里需要注意适配一下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;3.8 通过遍历statusBar的subviews中的UIStatusBarDataNetworkItemView获取网络状态在iPhoneX上会crash。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;问题原因:&lt;/p&gt;&lt;p&gt;之前我们采用遍历statusBar，获取UIStatusBarDataNetworkItemView实例，再获取网络状态的。代码如下：&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_95431&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;22&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;+&amp;nbsp;(NSNumber&amp;nbsp;*)&amp;nbsp;dataNetworkTypeFromStatusBar&amp;nbsp;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;UIApplication&amp;nbsp;*app&amp;nbsp;=&amp;nbsp;[UIApplication&amp;nbsp;sharedApplication];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;NSArray&amp;nbsp;*subviews&amp;nbsp;=&amp;nbsp;[[[app&amp;nbsp;valueForKey:@&lt;/code&gt;&lt;code class=&quot;as3 string&quot;&gt;&quot;statusBar&quot;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;]&amp;nbsp;valueForKey:@&lt;/code&gt;&lt;code class=&quot;as3 string&quot;&gt;&quot;foregroundView&quot;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;]&amp;nbsp;subviews];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;NSNumber&amp;nbsp;*dataNetworkItemView&amp;nbsp;=&amp;nbsp;nil;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;@&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;try&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;if&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;([subviews&amp;nbsp;count]&amp;nbsp;&amp;gt;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&amp;nbsp;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;for&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;(id&amp;nbsp;subview&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;in&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;subviews)&amp;nbsp;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;([subview&amp;nbsp;isKindOfClass:[NSClassFromString(@&lt;/code&gt;&lt;code class=&quot;as3 string&quot;&gt;&quot;UIStatusBarDataNetworkItemView&quot;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 color3&quot;&gt;class&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;]])&amp;nbsp;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;dataNetworkItemView&amp;nbsp;=&amp;nbsp;subview;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;break&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;@&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;catch&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;(NSException&amp;nbsp;*exception)&amp;nbsp;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;@&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;finally&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;{&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;&lt;code class=&quot;as3 spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 keyword&quot;&gt;return&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;[dataNetworkItemView&amp;nbsp;valueForKey:@&lt;/code&gt;&lt;code class=&quot;as3 string&quot;&gt;&quot;dataNetworkType&quot;&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;但是在iphoneX的statusBar的内部结构已经改变，不能根据遍历获取UIStatusBarDataNetworkItemView的状态获取网络状态状态。&lt;/p&gt;&lt;p&gt;可以通过&lt;strong&gt;po [statusBar recursiveDescription]&lt;/strong&gt;打印出来iphoneX内部结构了，可以看出变化非常的大。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用AFNetworking中的AFNetworkReachabilityManager类，或者使用&lt;a href=&quot;https://link.jianshu.com/?t=https://github.com/tonymillion/Reachability&quot; target=&quot;_blank&quot; _href=&quot;https://link.jianshu.com/?t=https://github.com/tonymillion/Reachability&quot;&gt;Reachability库&lt;/a&gt;获取网络连接状态。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;四、权限适配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;4.1 无法获取定位信息，第一次打开app也无法弹出定位权限提示框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;问题原因:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;iOS11 定位相关的权限做了更改，在iOS11上使用了新的定位权限key。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果原来申请的权限是始终允许NSLocationAlwaysUsageDescription，那么需要在保留原来的key的基础上增加NSLocationWhenInUseUsageDescription和NSLocationAlwaysAndWhenInUsageDescription。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;五、其他一些补充&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;5.1 如何判断该设备是不是iPhoneX&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772277385416.png&quot; title=&quot;1521772277385416.png&quot; _src=&quot;http://cc.cocimg.com/api/uploads//20180323/1521772277385416.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18px;&quot;&gt;&lt;strong&gt;5.2 一些常用的宏定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;div&gt;&lt;div id=&quot;highlighter_427004&quot; class=&quot;syntaxhighlighter  as3&quot;&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;5&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;IS_IPHONE_X&amp;nbsp;[KDDeviceHelper&amp;nbsp;is_iPhone_X]&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;IPHONE_NAVIGATIONBAR_HEIGHT&amp;nbsp;&amp;nbsp;(IS_IPHONE_X&amp;nbsp;?&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;88&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;:&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;64&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;IPHONE_STATUSBAR_HEIGHT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(IS_IPHONE_X&amp;nbsp;?&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;44&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;:&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;20&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;IPHONE_SAFEBOTTOMAREA_HEIGHT&amp;nbsp;(IS_IPHONE_X&amp;nbsp;?&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;34&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;:&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;as3 plain&quot;&gt;#define&amp;nbsp;IPHONE_TOPSENSOR_HEIGHT&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(IS_IPHONE_X&amp;nbsp;?&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;32&lt;/code&gt;&amp;nbsp;&lt;code class=&quot;as3 plain&quot;&gt;:&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;as3 value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;as3 plain&quot;&gt;)&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 20px;&quot;&gt;&lt;strong&gt;六、参考文献&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/204455df16d6&quot; target=&quot;_blank&quot; _href=&quot;https://www.jianshu.com/p/204455df16d6&quot;&gt;iOS11&amp;amp;iPhone X适配.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/AZFrqL9dnlgA6Vt2sVhxIw&quot; target=&quot;_blank&quot; _href=&quot;https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/AZFrqL9dnlgA6Vt2sVhxIw&quot;&gt;你可能需要为你的 APP 适配 iOS 11&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com/?t=http://blog.csdn.net/dangyalingengjia/article/details/77964582&quot; target=&quot;_blank&quot; _href=&quot;https://link.jianshu.com/?t=http://blog.csdn.net/dangyalingengjia/article/details/77964582&quot;&gt;升级到XCode9（BaseSDK:iOS11）的各种坑 持续更新中&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/2iG4oGzEGm9zQaDOsRgwLA&quot; target=&quot;_blank&quot; _href=&quot;https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/2iG4oGzEGm9zQaDOsRgwLA&quot;&gt;一个iOS 11BUG的发现、定位和解决&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d40d701889a6&quot; target=&quot;_blank&quot; _href=&quot;https://www.jianshu.com/p/d40d701889a6&quot;&gt;如何判断设备是否为iPhone X，iOS获取设备型号的方法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">iOS 11, Xcode 9 的一些适配问题</summary></entry></feed>