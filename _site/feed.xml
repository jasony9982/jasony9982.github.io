<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-21T10:59:26+08:00</updated><id>http://localhost:4000/</id><title type="html">仙居茶客</title><subtitle>袁培超的个人博客</subtitle><author><name>Peichao Yuan</name></author><entry><title type="html">如何避免卡顿掉帧</title><link href="http://localhost:4000/2018/06/21/ru-he-bi-miao-diao-zhen/" rel="alternate" type="text/html" title="如何避免卡顿掉帧" /><published>2018-06-21T00:00:00+08:00</published><updated>2018-06-21T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/21/ru-he-bi-miao-diao-zhen</id><content type="html" xml:base="http://localhost:4000/2018/06/21/ru-he-bi-miao-diao-zhen/">&lt;p&gt;本文主要讨论两个问题:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;nativie卡顿&lt;/li&gt;
  &lt;li&gt;网页卡顿&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;native卡顿&quot;&gt;Native卡顿&lt;/h2&gt;
&lt;p&gt;iOS客户端卡顿已经是老生常谈的问题了，解决方案各有千秋，大概做一个总结，不确定全部包括。&lt;/p&gt;

&lt;p&gt;iPhone的屏幕刷新频率是60FPS，即16ms一次，如果在一次渲染周期内无法将当前的内容渲染完成就会出现掉帧的情况。App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区。iOS显示系统有两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。&lt;/p&gt;

&lt;p&gt;当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象。为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 VSync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。&lt;/p&gt;

&lt;h3 id=&quot;常见解决方案&quot;&gt;常见解决方案&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;UIImageView尽量设置为不透明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIView的背景色尽量不要设置为clearColor，这样也会触发alpha叠加&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最好不使用带alpha通道的图片，如果有alpha尽量让美工取消alpha通道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cell上layer尽量避免使用圆角（避免离屏渲染等）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽量延迟图片的加载（布局特别复杂的cell，滑动时尽量不要加载图片）
注：严格意义上 self PerformSelector 的事件就是在主线程队列中等待。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适当使用预加载、预渲染等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让图片的绘制、图片的下载、对象的创建、文本的渲染等这些耗时的操作尽可能采用子线程异步的方式去处理（如ASDK）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Storyboard和XIB因为初始化对象分配内存先后的问题会导致CPU占用大于纯代码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实吧，我觉得主要还是分人，有些开发用起东西来就是费，完全不考虑成本。不过现在的机器的性能也确实好一些，一些小问题倒也看不出来，但这绝不是偷懒的借口。从小处着手，把每一行代码写好点，很多问题就解决了。&lt;/p&gt;

&lt;h2 id=&quot;网页卡顿&quot;&gt;网页卡顿&lt;/h2&gt;

&lt;p&gt;网页出现掉帧主要就是因为事件触发过于频繁，网页来不及处理导致在下一个事件被触发之前无法完成，特别在scroll resize这样的事件同时又涉及大量DOM操作和元素绘制的时候，网页掉帧就会比较严重。&lt;/p&gt;

&lt;p&gt;一个页面被呈现在用户面前之前，通常会经历JavaScript代码的加载和解释、计算样式、布局(layout)、为DOM元素填充像素(paint)、合并渲染层(DOM元素的绘制是在多个层上进行的,绘制完成后再进行合并)。具体过程可以参考之前写的浏览器的构成,浏览器内核，仅供参考。&lt;/p&gt;

&lt;p&gt;页面生成的时候会被至少渲染(layout+paint)一次，在被访问过程中也会不断地重排和重绘，特别是scroll resize的频繁触发会导致浏览器不停地重新渲染页面，通过元素的分组当某个层内容改变的时候，就可以仅仅重绘这个层，不需要整个页面重绘。也可以通过防抖函数,减少事件在一定时间内的触发次数，这样对网页展示会有很好的提升。&lt;/p&gt;

&lt;p&gt;结合防抖，采用节流函数，只允许一个函数在X毫秒内执行一次,只有当上一次函数执行后过了规定的时间间隔才能进行下一次该函数的调用。效果会更好一些。&lt;/p&gt;

&lt;h3 id=&quot;前端需要注意的地方&quot;&gt;前端需要注意的地方&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;尽量减少layout&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简化事件内操作,将一些变量的初始化,不依赖于位置变化的计算等都当在scroll外提前就绪&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;滑动过程中尝试使用pointer-events:none 禁止鼠标事件可以提高滚动时的帧频（使用后hover click事件会全部失效,要在停止滚动的时候移除掉这个属性）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简化DOM结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适当的开启硬件加速&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触发view前准备好数据，做好缓存&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;客户端可以做的事情&quot;&gt;客户端可以做的事情&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用WKWebView 替换 UIWebView&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理实现页面缓存技术（预加载Web页面， NSURLCache、NSURLProtocol ）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采用Hybrid等技术&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网页转成Native 等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">本文主要讨论两个问题: nativie卡顿 网页卡顿</summary></entry><entry><title type="html">iOS 保持界面流畅的技巧</title><link href="http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios/" rel="alternate" type="text/html" title="iOS 保持界面流畅的技巧" /><published>2018-05-22T00:00:00+08:00</published><updated>2018-05-22T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios</id><content type="html" xml:base="http://localhost:4000/2018/05/22/smooth_user_interfaces_for_ios/">&lt;blockquote&gt;
  &lt;p&gt;这篇文章会非常详细的分析 iOS 界面构建中的各种性能问题以及对应的解决思路，同时给出一个开源的微博列表实现，通过实际的代码展示如何构建流畅的交互。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原文作者为YYKit的作者，对他在知识面以及开源界的领导力和影响表示钦佩！&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios&quot;&gt;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Index&lt;br /&gt;
&lt;a href=&quot;#1&quot;&gt;演示项目&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#2&quot;&gt;屏幕显示图像的原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#3&quot;&gt;卡顿产生的原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#31&quot;&gt;CPU 资源消耗原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#32&quot;&gt; GPU 资源消耗原因和解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#4&quot;&gt; AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#41&quot;&gt;ASDK 的由来&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#42&quot;&gt;ASDK 的资料&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#43&quot;&gt;ASDK 的基本原理&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#44&quot;&gt;ASDK 的图层预合成&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#45&quot;&gt;ASDK 异步并发操作&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#46&quot;&gt;Runloop 任务分发&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#5&quot;&gt;微博 Demo 性能优化技巧&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#51&quot;&gt;预排版&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#52&quot;&gt;预渲染&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#53&quot;&gt;异步绘制&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#54&quot;&gt;全局并发控制&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#55&quot;&gt;更高效的异步图片加载&lt;/a&gt;&lt;br /&gt;
&lt;a style=&quot;padding-left: 30px;&quot; href=&quot;#56&quot;&gt;其他可以改进的地方&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;#6&quot;&gt;如何评测界面的流畅度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;演示项目&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;在开始技术讨论前，你可以先下载我写的 Demo 跑到真机上体验一下：&lt;a href=&quot;https://github.com/ibireme/YYKit&quot; target=&quot;_blank&quot;&gt;https://github.com/ibireme/YYKit&lt;/a&gt;。 Demo 里包含一个微博的 Feed 列表、发布视图，还包含一个 Twitter 的 Feed 列表。为了公平起见，所有界面和交互我都从官方应用原封不动的抄了过来，数据也都是从官方应用抓取的。你也可以自己抓取数据替换掉 Demo 中的数据，方便进行对比。尽管官方应用背后的功能更多更为复杂，但不至于会带来太大的交互性能差异。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41926&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo.png&quot; alt=&quot;weibo&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo_compose.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41927&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/weibo_compose.png&quot; alt=&quot;weibo_compose&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/twitter.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41928&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/twitter.png&quot; alt=&quot;twitter&quot; width=&quot;230&quot; height=&quot;409&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;这个 Demo 最低可以运行在 iOS 6 上，所以你可以把它跑到老设备上体验一下。在我的测试中，即使在 iPhone 4S 或者 iPad 3 上，Demo 列表在快速滑动时仍然能保持 50~60 FPS 的流畅交互，而其他诸如微博、朋友圈等应用的列表视图在滑动时已经有很严重的卡顿了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;微博的 Demo 有大约四千行代码，Twitter 的只有两千行左右代码，第三方库只用到了 YYKit，文件数量比较少，方便查看。好了，下面是正文。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-41893&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;屏幕显示图像的原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41896&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png&quot; alt=&quot;ios_screen_scan&quot; width=&quot;321&quot; height=&quot;239&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41897&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png&quot; alt=&quot;ios_screen_display&quot; width=&quot;546&quot; height=&quot;251&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-41898&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg&quot; alt=&quot;ios_vsync_off&quot; width=&quot;500&quot; height=&quot;294&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;卡顿产生的原因和解决方案&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41899&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png&quot; alt=&quot;ios_frame_drop&quot; width=&quot;712&quot; height=&quot;184&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;31&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;CPU 资源消耗原因和解决方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象调整&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;对象销毁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&amp;lt;div id=&quot;crayon-5b043341ea225034597315&quot; class=&quot;crayon-syntax crayon-theme-familiar-mynew crayon-font-consolas crayon-os-mac print-yes notranslate&quot; data-settings=&quot; minimize scroll-mouseover wrap&quot; style=&quot; margin-top: 5px; margin-bottom: 5px; font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt;
	
		&amp;lt;div class=&quot;crayon-plain-wrap&quot;&amp;gt;&amp;lt;textarea  class=&quot;crayon-plain print-no&quot; data-settings=&quot;&quot; readonly style=&quot;-moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4; font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt; NSArray *tmp = self.array; self.array = nil; dispatch_async(queue, ^{
[tmp class]; });&amp;lt;/textarea&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;crayon-main&quot; style=&quot;&quot;&amp;gt;
			&amp;lt;table class=&quot;crayon-table&quot;&amp;gt;
				&amp;lt;tr class=&quot;crayon-row&quot;&amp;gt;
			&amp;lt;td class=&quot;crayon-nums &quot; data-settings=&quot;hide&quot;&amp;gt;
				&amp;lt;div class=&quot;crayon-nums-content&quot; style=&quot;font-size: 13px !important; line-height: 15px !important;&quot;&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-1&quot;&amp;gt;1&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-2&quot;&amp;gt;2&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-3&quot;&amp;gt;3&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-4&quot;&amp;gt;4&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-num&quot; data-line=&quot;crayon-5b043341ea225034597315-5&quot;&amp;gt;5&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;/td&amp;gt;
					&amp;lt;td class=&quot;crayon-code&quot;&amp;gt;&amp;lt;div class=&quot;crayon-pre&quot; style=&quot;font-size: 13px !important; line-height: 15px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;&quot;&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-1&quot;&amp;gt;&amp;lt;span class=&quot;crayon-e &quot;&amp;gt;NSArray *&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;tmp&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-r&quot;&amp;gt;self&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;array&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-2&quot;&amp;gt;&amp;lt;span class=&quot;crayon-r&quot;&amp;gt;self&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;array&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;nil&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-3&quot;&amp;gt;&amp;lt;span class=&quot;crayon-e&quot;&amp;gt;dispatch_async&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-v&quot;&amp;gt;queue&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;,&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-o&quot;&amp;gt;^&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;{&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-4&quot;&amp;gt;&amp;lt;span class=&quot;crayon-h&quot;&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-e&quot;&amp;gt;tmp &amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-t&quot;&amp;gt;class&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;]&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;crayon-line&quot; id=&quot;crayon-5b043341ea225034597315-5&quot;&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;}&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;)&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;crayon-sy&quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/td&amp;gt;
				&amp;lt;/tr&amp;gt;
			&amp;lt;/table&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt; &amp;lt;!-- [Format Time: 0.0003 seconds] --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt; 布局计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;Autolayout&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：&lt;a href=&quot;http://pilky.me/36/&quot; target=&quot;_blank&quot;&gt;http://pilky.me/36/&lt;/a&gt;。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;文本计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;文本渲染&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;图片的解码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt; 图像的绘制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- Crayon Syntax Highlighter v_2.7.2_beta --&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)display {
    dispatch_async(backgroundQueue, ^{
        CGContextRef ctx = CGBitmapContextCreate(...);
        // draw in context...
        CGImageRef img = CGBitmapContextCreateImage(ctx);
        CFRelease(ctx);
        dispatch_async(mainQueue, ^{
            layer.contents = img;
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- [Format Time: 0.0004 seconds] --&gt;
&lt;p&gt;&lt;a name=&quot;32&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt; GPU 资源消耗原因和解决方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;纹理的渲染&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096&amp;#215;4096，更详细的资料可以看这里：&lt;a href=&quot;http://iosres.com&quot; target=&quot;_blank&quot;&gt;iosres.com&lt;/a&gt;。所以，尽量不要让图片和视图的大小超过这个值。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;视图的混合 (Composing)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #8dd400;&quot;&gt;图形的生成。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;AsyncDisplayKit&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;41&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的由来&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/scott_goodson.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41900&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/scott_goodson.png&quot; alt=&quot;scott_goodson&quot; width=&quot;150&quot; height=&quot;150&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 的作者是 Scott Goodson (&lt;a href=&quot;https://www.linkedin.com/in/iosengineer&quot; target=&quot;_blank&quot;&gt;Linkedin&lt;/a&gt;)，&lt;br /&gt;
他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置、Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_history.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41901&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_history.png&quot; alt=&quot;asdk_history&quot; width=&quot;484&quot; height=&quot;160&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。&lt;br /&gt;
V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。&lt;br /&gt;
现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;42&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的资料&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;想要了解 ASDK 的原理和细节，最好从下面几个视频开始：&lt;br /&gt;
2014.10.15 &lt;a href=&quot;https://www.youtube.com/watch?v=-IPMNWqA638&quot; target=&quot;_blank&quot;&gt;NSLondon &amp;#8211; Scott Goodson &amp;#8211; Behind AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
2015.03.02 &lt;a href=&quot;https://www.youtube.com/watch?v=ZPL4Nse76oY&quot; target=&quot;_blank&quot;&gt;MCE 2015 &amp;#8211; Scott Goodson &amp;#8211; Effortless Responsiveness with AsyncDisplayKit&lt;/a&gt;&lt;br /&gt;
2015.10.25 &lt;a href=&quot;https://www.youtube.com/watch?v=RY_X7l1g79Q&quot; target=&quot;_blank&quot;&gt;AsyncDisplayKit 2.0: Intelligent User Interfaces &amp;#8211; NSSpain 2015&lt;/a&gt;&lt;br /&gt;
前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。&lt;br /&gt;
后一个视频增加了 ASDK 2.0 的新特性的介绍。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容：&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/42&quot; target=&quot;_blank&quot;&gt;关于 Runloop Dispatch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/70&quot; target=&quot;_blank&quot;&gt;关于 ComponentKit 和 ASDK 的区别&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/132&quot; target=&quot;_blank&quot;&gt;为什么不支持 Storyboard 和 Autolayout&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/issues/204&quot; target=&quot;_blank&quot;&gt;如何评测界面的流畅度&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;之后，还可以到 Google Groups 来查看和讨论更多内容：&lt;br /&gt;
&lt;a href=&quot;https://groups.google.com/forum/#!forum/asyncdisplaykit&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!forum/asyncdisplaykit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;43&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的基本原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_design.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41902&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_design.png&quot; alt=&quot;asdk_design&quot; width=&quot;496&quot; height=&quot;255&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_view.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41903&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_view.png&quot; alt=&quot;asdk_layer_backed_view&quot; width=&quot;363&quot; height=&quot;162&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_view_backed_node.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41904&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_view_backed_node.png&quot; alt=&quot;asdk_view_backed_node&quot; width=&quot;605&quot; height=&quot;165&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&amp;gt;CALayer 相同的方式，实现了 ASNode-&amp;gt;UIView 这样一个关系。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_node.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41905&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_layer_backed_node.png&quot; alt=&quot;asdk_layer_backed_node&quot; width=&quot;605&quot; height=&quot;167&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;44&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 的图层预合成&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_comoose_1.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41906&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_comoose_1.png&quot; alt=&quot;asdk_comoose_1&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_compose_2.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41907&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_compose_2.png&quot; alt=&quot;asdk_compose_2&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;45&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;ASDK 异步并发操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_a9_chip.jpg&quot;&gt;&lt;img class=&quot;alignnone wp-image-41908&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/asdk_a9_chip.jpg&quot; alt=&quot;asdk_a9_chip&quot; width=&quot;313&quot; height=&quot;176&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;46&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;Runloop 任务分发&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章&lt;a href=&quot;https://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot;&gt; 深入理解RunLoop&lt;/a&gt;，里面对 ASDK 也有所提及。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_runloop.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41909&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_runloop.png&quot; alt=&quot;ios_vsync_runloop&quot; width=&quot;564&quot; height=&quot;234&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m&quot; target=&quot;_blank&quot;&gt;ASAsyncTransactionGroup&lt;/a&gt;。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;微博 Demo 性能优化技巧&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;51&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;预排版&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：&lt;a href=&quot;https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/&quot; target=&quot;_blank&quot;&gt;FDTemplateLayoutCell&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;52&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;预渲染&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;53&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;异步绘制&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：&lt;a href=&quot;https://github.com/ibireme/YYAsyncLayer&quot; target=&quot;_blank&quot;&gt;YYAsyncLayer&lt;/a&gt;。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 &lt;span style=&quot;color: #008000;&quot;&gt;BOOL(^isCancelled)()&lt;/span&gt; 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot; target=&quot;_blank&quot;&gt;VVeboTableViewDemo&lt;/a&gt;。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;54&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;全局并发控制&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;&lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_1.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41910&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_1.png&quot; alt=&quot;ios_dispatch_blocked_1&quot; width=&quot;330&quot; height=&quot;609&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_2.png&quot;&gt;&lt;img class=&quot;alignnone wp-image-41911&quot; src=&quot;https://blog.ibireme.com/wp-content/uploads/2015/11/ios_dispatch_blocked_2.png&quot; alt=&quot;ios_dispatch_blocked_2&quot; width=&quot;340&quot; height=&quot;445&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit/tree/master/examples/SocialAppLayout&quot; target=&quot;_blank&quot;&gt;SocialAppLayout&lt;/a&gt;，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 &lt;a href=&quot;https://github.com/ibireme/YYDispatchQueuePool&quot; target=&quot;_blank&quot;&gt;YYDispatchQueuePool&lt;/a&gt;，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;55&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;更高效的异步图片加载&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;56&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;none&quot;&gt;&lt;strong&gt;其他可以改进的地方&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;none&quot;&gt;上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;none&quot;&gt;&lt;strong&gt;如何评测界面的流畅度&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;none&quot;&gt;最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&amp;gt; Profile -&amp;gt; 修改代码这样一个流程，优先解决最值得优化的地方。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;如果你需要一个明确的 FPS 指示器，可以尝试一下 &lt;a href=&quot;https://github.com/kconner/KMCGeigerCounter&quot; target=&quot;_blank&quot;&gt;KMCGeigerCounter&lt;/a&gt;。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1&amp;#215;1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;我自己也写了个简单的 FPS 指示器：&lt;a href=&quot;https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m&quot; target=&quot;_blank&quot;&gt;FPSLabel&lt;/a&gt; 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。&lt;/p&gt;
&lt;p class=&quot;none&quot;&gt;最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">这篇文章会非常详细的分析 iOS 界面构建中的各种性能问题以及对应的解决思路，同时给出一个开源的微博列表实现，通过实际的代码展示如何构建流畅的交互。</summary></entry><entry><title type="html">atomic 和 nonatomic 的区别</title><link href="http://localhost:4000/2018/05/21/atomic-nonatomic/" rel="alternate" type="text/html" title="atomic 和 nonatomic 的区别" /><published>2018-05-21T00:00:00+08:00</published><updated>2018-05-21T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/21/atomic-nonatomic</id><content type="html" xml:base="http://localhost:4000/2018/05/21/atomic-nonatomic/">&lt;blockquote&gt;
  &lt;p&gt;今天面试小伙伴的时候问到了 atomic 和 nonatomic 的区别，感觉回答的不太完善，这里是比较详细的回答&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;问题下面三种写法有什么区别&quot;&gt;问题：下面三种写法有什么区别&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;解答&quot;&gt;解答&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;解释
后两行是一样的，不写的话默认就是atomic。&lt;/p&gt;

    &lt;p&gt;atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。&lt;/p&gt;

    &lt;p&gt;对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。&lt;/p&gt;

    &lt;p&gt;而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。&lt;/p&gt;

    &lt;p&gt;不过atomic可并不能保证线程安全。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;苹果的官方文档&lt;/a&gt; 有解释了，下面我们举例子解释一下背后的原理。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//@property(atomic, strong) UITextField *textField;
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setTextField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//@property(atomic, strong) UITextField *textField;
&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//系统生成的代码如下：
&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;@synchronized&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;autorelease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setTextField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITextField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;@synchronized&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;_textField&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textField&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;简单来说，就是 atomic 会加一个锁来保障线程安全，并且引用计数会 +1，来向调用者保证这个对象会一直存在。假如不这样做，如有另一个线程调 setter，可能会出现线程竞态，导致引用计数降到0，原来那个对象就释放掉了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;《realm》对atomic和nonatomic的解释&lt;/p&gt;

    &lt;p&gt;atomic (default)&lt;/p&gt;

    &lt;p&gt;Atomic is the default: if you don’t type anything, your property is atomic. An atomic property is guaranteed that if you try to read from it, you will get back a valid value. It does not make any guarantees about what that value might be, but you will get back good data, not just junk memory. What this allows you to do is if you have multiple threads or multiple processes pointing at a single variable, one thread can read and another thread can write. If they hit at the same time, the reader thread is guaranteed to get one of the two values: either before the change or after the change. What atomic does not give you is any sort of guarantee about which of those values you might get. Atomic is really commonly confused with being thread-safe, and that is not correct. You need to guarantee your thread safety other ways. However, atomic will guarantee that if you try to read, you get back some kind of value.&lt;/p&gt;

    &lt;p&gt;nonatomic&lt;/p&gt;

    &lt;p&gt;On the flip side, non-atomic, as you can probably guess, just means, “don’t do that atomic stuff.” What you lose is that guarantee that you always get back something. If you try to read in the middle of a write, you could get back garbage data. But, on the other hand, you go a little bit faster. Because atomic properties have to do some magic to guarantee that you will get back a value, they are a bit slower. If it is a property that you are accessing a lot, you may want to drop down to nonatomic to make sure that you are not incurring that speed penalty.&lt;/p&gt;

    &lt;p&gt;其中Atomic is really commonly confused with being thread-safe, and that is not correct. You need to guarantee your thread safety other ways.这句话明确说明Atomic不能保证对象多线程的安全。所以Atomic 不能保证对象多线程的安全。它只是能保证你访问的时候给你返回一个完好无损的Value而已。举个例子：&lt;/p&gt;

    &lt;p&gt;如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，有3种可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。所以atomic可并不能保证对象的线程安全。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;atomic和nonatomic的对比&quot;&gt;atomic和nonatomic的对比&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;atomic：系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。getter 还是能得到一个完好无损的对象（可以保证数据的完整性），但这个对象在多线程的情况下是不能确定的，比如上面的例子。&lt;/p&gt;

    &lt;p&gt;也就是说：如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，每次只能有一个线程调用对象的setter方法，所以可以保证数据的完整性。&lt;/p&gt;

    &lt;p&gt;atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nonatomic：就没有这个保证了，nonatomic返回你的对象可能就不是完整的value。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。但仅仅使用atomic并不会使得对象线程安全，我们还要为对象线程添加lock来确保线程的安全。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nonatomic的速度要比atomic的快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;atomic与nonatomic的本质区别其实也就是在setter方法上的操作不同&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">今天面试小伙伴的时候问到了 atomic 和 nonatomic 的区别，感觉回答的不太完善，这里是比较详细的回答</summary></entry><entry><title type="html">小狐狸和小兔子的故事</title><link href="http://localhost:4000/2018/05/20/xiao-tu-zi-xiao-hu-li/" rel="alternate" type="text/html" title="小狐狸和小兔子的故事" /><published>2018-05-20T00:00:00+08:00</published><updated>2018-05-20T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/20/xiao-tu-zi-xiao-hu-li</id><content type="html" xml:base="http://localhost:4000/2018/05/20/xiao-tu-zi-xiao-hu-li/">&lt;blockquote&gt;
  &lt;p&gt;这里是一只小狐狸和小兔子的故事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸偷偷喜欢上了一只小兔子。他每天傍晚都要跑到一个无人的山谷大喊一声“小兔子,我喜欢你!”然后山谷里就会传来“我喜欢你”的回音。小狐狸就那么喊了九十九天,等到一百天时他已经决定要放弃了。他最后一次来到山谷大声地几乎是绝望地喊道:“我喜欢你”。“我也喜欢你”, 山谷的某处传来了回应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;入冬了,怕冷的小狐狸去小兔子开的森林杂货铺买了一件温暖牌的毛衣,一条温暖牌的围巾,还有一个温暖牌的水杯。小狐狸待在家里穿着毛衣戴着围巾喝着杯子里的热水，可还是觉得有点冷,“到底还缺些什么呢?”小狐狸想了想那家森林杂货铺还有铺子里那只可爱的小兔子,“大概我还缺一个温暖牌的拥抱。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸总是忍不住偷偷看小兔子,他尤其喜欢看小兔子那双温柔的红眼睛。但小狐狸的偷看实在太明显了,有时本来只是想悄无声息地看一眼的,可不自觉就着了迷变成了紧紧地注视。“干吗总是盯着我看?”小兔子有天假装生气地问。“我哪有？”小狐狸不肯承认。但在说完这句话的第二天,小狐狸就得了红眼病。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最近胡萝卜大丰收。小兔子吃了好多好多胡萝卜,结果把自己吃成了一个小胖子。这天傍晚她和小狐狸一起在森林里散步时,突然像她从前常常做的那样一下子跳到了小狐狸的背上想要小狐狸背着她走。可小狐狸却一下被压倒在了地上,“我是不是该减肥了?”小兔子哭着对小狐狸说,似乎第一次意识到现在的自己究竟有多重,“不是的,”小狐狸趴在地上说,“是我该锻炼身体了。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“小狐狸,如果我和你妈妈同时掉进水里面了,你会先救谁呢?”小兔子问小狐狸。“当然是先救你啊。”小狐狸想都没想就回答。小兔子心里很开心,但表面还是假装生气 地问道:“为什么要先救我呢?那你妈妈该怎么办啊?”“我妈妈才不会和我计较这种傻问题呢。”小狐狸在心里想。被小兔子问了那个“你会先救谁”的问题之后,小狐狸当时虽然不在意,可后来还是去了游泳学校一边学习游泳一边在心里思索着这个问题。在被水呛到了好几次之后小狐狸学会了游泳,可那个问题依旧没有答案。于是有天小狐狸就不再去学游泳了,“还是不会游泳的好,”小狐狸心想,“这样如果我妈妈和小兔子都掉河里了,我也跳下去陪它们好了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”小狐狸最喜欢做的事就是吹泡泡糖了。而且最厉害的是它能把泡泡糖吹成不同的形状。“你能吹出一个胡萝卜来吗?”小兔子有天对小狐狸说。“当然!”小狐狸脑海中想象着胡萝卜的样子然后就把泡泡吹了出来。果然是一根胡萝卜的形状。“小狐狸,你简直是个魔法师!”小兔子尖叫道, “那你能吹出一个和我长得一模一样的泡泡来吗?”小兔子问。“这有什么难的?”小狐狸一边看着小兔子一边吹起了泡泡糖。可它吹出来的泡泡却是一颗心的模样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”我能亲亲你吗?”小狐狸问身边正在吃爆米花的小兔子。“嗯……”小兔子歪着脑袋想了想,“我们一人吃一口爆米花吧,如果这袋爆米花最后一个是你吃到的我就让你亲我。”小兔子说。结果是小兔子吃到了最后一个。小狐狸沮丧地低下了头,小兔子却迅速亲了一下他的脸庞。“如果是我吃到,就换我来亲你。”小兔子补充道。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;天空突然下起了大雨,小兔子被困在了一株大蘑菇底下。过了一会儿来了一只可爱的小松鼠,他看到在大蘑菇下面避雨的小兔子就问她:“我送你回家好吗?”“谢谢你小松鼠,不过我正在等人呢。”小兔子说。“那我把我的这把伞给你好了。”小松鼠说。“不用了,我想我不需要雨伞。”小兔子说。于是小松鼠有些失望地走了。过了好大一会儿小狐狸从大雨中冲了过来,“大笨蛋,你的伞呢?”小兔子看着浑身湿透的小狐狸心疼地问道。“我不是来给你送伞的,”小狐狸对小兔子说,“我是来陪你一起淋雨的。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“小兔子,感到快乐的时候你最喜欢做什么呢?”“当然是跳舞啦。”“那感到悲伤的时候呢?”“嗯……也会跳舞吧。”“为什么快乐和悲伤的时候都要跳舞呢?”“因为无论是快乐或悲伤都是舞蹈时的一种舞步吧。”…………自从认识了小兔子之后,小狐狸每次一个人走路时,总是忍不住会一边想着小兔子一边在嘴边哼着一首又一首他都不知道是从哪里听来的歌儿。可能是因为小兔子,也可能是因为这些歌曲,小狐狸觉得他走过的每一步都成了舞步。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子看到小狐狸正在愁眉苦脸地吃着一根胡萝卜,“你今天怎么啦?”小兔子觉得有些奇怪,“你不是最讨厌吃胡萝卜了吗?”“可是你喜欢啊,”小狐狸说,“你喜欢的东西我也都想喜欢。”小兔子微微一愣,然后不由得微笑了起来。“那你知道你最应该喜欢的东西是什么吗?”小兔子问。“是什么?”“是你自己呀。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸从小到大从未曾对什么事物感到恐怖过。它不怕狮子老虎大象鳄鱼,当然也不怕流传在森林里的各种恐怖传说。但小狐狸却很想感受一下恐惧究竟是一种什么样的感觉。 为了让小狐狸的愿望达成,小兔子开始每天晚上给小狐狸讲一个鬼故事。可整整一个月了,小狐狸每次听故事时总是一副不为所动的样子,脸上没有丝毫恐惧的表情。小兔子气馁极了。“我不讲啦!”有天小兔子忍不住说道。终于解脱了, 小狐狸心想。可小狐狸刚转身准备要走,小兔子又突然生气地说了一句:“什么都不害怕,你根本就是个冷血动物!”小狐狸迈起的脚步突然停下了,它缓缓地转过身子,眼睛有些失神地看着小兔子,“我想我刚刚知道什么是恐惧了。”小狐狸说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸一边在小溪边钓着鱼一边想着和小兔子有关的事,不知不觉就入了迷。天已经黑了他还没有收拾起鱼竿回家睡觉。小兔子晚上恰巧也睡不着觉,一个人出门散步不知不觉就走到了小溪边。小兔子看到了小狐狸便走向前拍了一下他的肩膀。小狐狸从幻想中惊醒,有些慌张地回头看了看小兔子。然后好像自己的秘密被人揭穿了似的,他把视线慌忙地从小兔子明亮的眼睛上移开。“这么晚了你怎么还不回家?”小兔子的声音从身后传来。“我,我,”小狐狸一时不知该怎么回答,过了一会儿他才看着映满星光的河面说道,“我正在钓星星呢。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子和小狐狸大吵了一架。小兔子发誓以后再也不要和小狐狸说话了。可第二天小狐狸还是忍不住想要去找小兔子。在去小兔子家的路上小狐狸遇到了一只正在爬树的母猪,小狐狸问她:“你为什么要在这里爬树啊?你难道不知道你永远都爬不上吗?” 那只母猪看了看小狐狸,然后嗤嗤地笑了起来,过了一会儿,她忍住笑似的对小狐狸说:“你还说我呢,你不也正去找一个永远都不肯再见你的人吗?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小兔子不肯见小狐狸,小狐狸晚上睡不着觉,就坐在草地上对着漫天的萤火虫诉说自己的心事。“答应我,你们可不能把我刚才说的话讲给别人听。”小狐狸对萤火虫们吩咐道,然后起身回家去了。小狐狸刚刚离开小兔子也跑到了这片草地上。 “刚刚那个说话的影子是小狐狸吗?”小兔子问萤火虫。“是啊,是啊。”萤火虫们回答。“那你们可以告诉我刚刚小狐狸都说了什么吗?”小兔子问。“不可以,不可以,”萤火虫们说,“我们答应过小狐狸的。”小兔子有些难过地低下了头。萤火虫们平时最喜欢小兔子了,看到她沮丧的样子心中都有些不忍。“不过我们虽然答应过小狐狸不说给别人听,”一只萤火虫说道,“可不代表我们不可以用别的方式告诉小兔子啊。”“对啊对啊。”其余的萤火虫附和道。萤火虫们交头接耳地商量了一会儿,突然开始在空中迅速而有序地飞舞起来,不大一会儿,几百只萤火虫用自己身上的荧光一点一点在黑夜中组成了一行闪着光的字。小兔子抬头看去,那行光字写的是:小狐狸说他很想你。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;森林里有一棵很老很老的古树,大树的树身被岁月掏出了一个巨大的树洞。森林里的小动物们习惯把自己的秘密对着树洞说出来。那天小兔子来到了大树下。“其实我也不是那么讨厌小狐狸,”小兔子对着树洞自言自语道,“虽然有时我喜欢凶他,挑他的毛病,无缘无故地不理他,但其实我是有一点点喜欢他的,”小兔子摇了摇脑袋,继续说道,“上次发脾气是我不对,如果小狐狸能在这里就好了,我有点想他了。” 小兔子边说边轻轻地叹息了一声。 “我在。”突然有一个低低的声音从树洞里传来。 小狐狸从漆黑的树洞里钻了出来,“对不起,我不是故意偷听的。”小狐狸解释道,把手里的皮球朝小兔子举了举,“我的皮球不小心踢进树洞里了,我是来捡皮球的。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从前小兔子还在森林杂货铺打工时,小狐狸为了接近她几乎每天都要跑去森林杂货铺买一包水果硬糖。结果一个月下来小狐狸的牙便开始疼了起来。为了让小狐狸的牙疼快快消除,小兔子去山里采了好多草药熬汤给它喝。可小狐狸却总是趁小兔子不注意的时候把碗里的药汤偷偷倒掉。因为他想一直这样牙疼下去,它想让小兔子一直陪在自己身边。“你为什么要把药倒掉?”有天小兔子发现后生气地责问小狐狸, “因为我怕……”小狐狸支支吾吾地说,“因为我怕苦。”“那你就不怕牙疼吗?”小兔子问。可是小狐狸当然不怕牙疼。对小狐狸来说,牙疼只是甜蜜的同义词。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸和小兔子一人提着一大袋零食,散着步走去森林电影院去看一部新上映的关于永恒的爱情电影。电影开场前的一分钟,小兔子问小狐狸他会不会永远爱自己。小狐狸想了想说,他不知道永远是什么。然后他拿起装满零食的袋子对小兔子说:“但我会爱你直至这个塑料袋自行降解。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;夏日的夜晚,小兔子和小狐狸躺在一片林中空地上一起看星星。“小狐狸,你说天上的星星究竟有多少颗呢?”一阵凉风吹过时小兔子问小狐狸。“嗯……”小狐狸想了想, 然后说:“我最多的一次是数1314 颗就睡着了,所以我 不知道天上的星星究竟有多少颗。但我知道地上的星星有多少……”小狐狸转过身看着小兔子明亮的大眼睛说,“地上的星星只有两颗。”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸已经就快成年了,根据狐狸家族的传统,每只小狐狸为了迎接自己的成年礼都需要深入到森林的腹地进行一次探险。每只小狐狸只有在这场充满了危险与艰难的探险中找到属于自己的生命的意义才能合格地通过成年礼的考验。 那天小狐狸告别小兔子开始了他的旅程。整整三个月的时间里小狐狸的足迹几乎踏过了森林里的每一片土地,他经历了一次又一次险情,也结交了许许多多的新朋友。但生命的意义对于小狐狸来说仍然是一片茫然。直到三个月后他重新站到小兔子的房子前面,直到小兔子从房子里走了出来站在家门口一动不动地看着他时,小狐狸才终于明白了这场跋涉的意义,他在心里悄悄对小兔子说:原来逛遍了整片森林,只是为了再次回到你家门前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小狐狸仰躺在草地上看着天空中的云朵。天空中那些白色的云朵对小狐狸来说只分两种:像小兔子的和不像小兔子的。刚刚开始看时自然是不像小兔子的云朵较多,可看着看着小狐狸就几乎能够在每一片云朵上都找到小兔子的影子了。天色渐晚,等小狐狸起身回家时,天空中已布满了小兔子。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;森林小学这个星期的作文题目是《我最爱的××》, 小老虎写了《我最爱的森林》得了最高分,九十九分,小浣熊写了《我最爱的老师》,得了八十五分,小狐狸写的《我最爱的小兔子》却因为涉及早恋老师只给了十分。“对不起,” 放学后小狐狸对小兔子说,“我对你的爱才得了十分。”“那是因为你十分爱我啊。”小兔子微笑着说。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;转载&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">这里是一只小狐狸和小兔子的故事</summary></entry><entry><title type="html">睡前小故事二-下篇</title><link href="http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia/" rel="alternate" type="text/html" title="睡前小故事二-下篇" /><published>2018-05-18T00:00:00+08:00</published><updated>2018-05-18T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia</id><content type="html" xml:base="http://localhost:4000/2018/05/18/shui-qian-xiao-gu-shi-er-xia/">&lt;blockquote&gt;
  &lt;p&gt;接上篇&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;猫太太是一只不一样的猫&lt;/p&gt;

&lt;p&gt;她不爱吃鱼&lt;/p&gt;

&lt;p&gt;却偏爱吃水果&lt;/p&gt;

&lt;p&gt;可这鬼天气持续了很久&lt;/p&gt;

&lt;p&gt;尽管他们存储了足够多的鱼肉，腊肉&lt;/p&gt;

&lt;p&gt;但是新鲜的水果却不能存储太多&lt;/p&gt;

&lt;p&gt;猫先生吃喝完毕&lt;/p&gt;

&lt;p&gt;从自己的百宝箱中替猫太太找出了一罐水果罐头&lt;/p&gt;

&lt;p&gt;这才让猫太太的脸上露出了笑容&lt;/p&gt;

&lt;p&gt;吃完饭猫先生告诉猫太太&lt;/p&gt;

&lt;p&gt;他们的屋子里取暖的木材不多了&lt;/p&gt;

&lt;p&gt;他要去买一些木材&lt;/p&gt;

&lt;p&gt;说着就穿上风衣带上墨镜踏入了风雪&lt;/p&gt;

&lt;p&gt;猫太太担忧的站在窗边&lt;/p&gt;

&lt;p&gt;看着猫先生走向远方&lt;/p&gt;

&lt;p&gt;也越来越深&lt;/p&gt;

&lt;p&gt;猫先生还没有回来&lt;/p&gt;

&lt;p&gt;猫太太把做好的炒肉热了一遍又一遍&lt;/p&gt;

&lt;p&gt;也不见猫先生回来&lt;/p&gt;

&lt;p&gt;猫太太又生气了&lt;/p&gt;

&lt;p&gt;他就不知道早点回家吗&lt;/p&gt;

&lt;p&gt;不能早点回来也不知道提前打个招呼吗&lt;/p&gt;

&lt;p&gt;嘎吱&lt;/p&gt;

&lt;p&gt;门响了&lt;/p&gt;

&lt;p&gt;从门里滚进来一个圆滚滚的雪球&lt;/p&gt;

&lt;p&gt;还没等到猫太太尖叫&lt;/p&gt;

&lt;p&gt;这个雪球就滚掉了身上一层一层的雪花&lt;/p&gt;

&lt;p&gt;变成了一个冻得冰冰的猫先生&lt;/p&gt;

&lt;p&gt;猫太太忘记了生气&lt;/p&gt;

&lt;p&gt;开心的扑倒在了猫先生的身上&lt;/p&gt;

&lt;p&gt;两只喵打成了一个滚&lt;/p&gt;

&lt;p&gt;猫先生等他闹够了&lt;/p&gt;

&lt;p&gt;神秘兮兮的把她拉到屋后&lt;/p&gt;

&lt;p&gt;哇&lt;/p&gt;

&lt;p&gt;猫太太发誓她从来没有见到过这么多的苹果和梨&lt;/p&gt;

&lt;p&gt;他虽然抱怨着猫先生乱花钱&lt;/p&gt;

&lt;p&gt;可依旧开心的吃着新鲜的水果&lt;/p&gt;

&lt;p&gt;这段时间她馋坏了&lt;/p&gt;

&lt;p&gt;猫先生考虑的很周到&lt;/p&gt;

&lt;p&gt;他原本就计划好&lt;/p&gt;

&lt;p&gt;把这些水果都做成冻梨冻苹果&lt;/p&gt;

&lt;p&gt;这个冬天&lt;/p&gt;

&lt;p&gt;猫小姐体会到了她从未缺少过的甜蜜&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ending&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">接上篇</summary></entry><entry><title type="html">睡前小故事二-上篇</title><link href="http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er/" rel="alternate" type="text/html" title="睡前小故事二-上篇" /><published>2018-05-16T00:00:00+08:00</published><updated>2018-05-16T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er</id><content type="html" xml:base="http://localhost:4000/2018/05/16/shui-qian-xiao-gu-shi-er/">&lt;blockquote&gt;
  &lt;p&gt;今天讲的是猫先生和猫太太的故事，有猫先生和猫太太，那猫孩子哪。筒子们，今天的重点是猫先生和猫太太…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;天空中飘着大雪&lt;/p&gt;

&lt;p&gt;银白的雪伟大地覆盖了一层冰沙&lt;/p&gt;

&lt;p&gt;在这一望无垠的原野上有一座砖瓦小屋&lt;/p&gt;

&lt;p&gt;矮小的它在猫先生看来就是一座城堡&lt;/p&gt;

&lt;p&gt;再豪华的宅院他也不会去换&lt;/p&gt;

&lt;p&gt;为什么？&lt;/p&gt;

&lt;p&gt;猫先生可能要哈哈大笑了：这里是这片原野上唯一可以取暖的地方&lt;/p&gt;

&lt;p&gt;别的地方再好他也难以拥有这种唯一的重要性&lt;/p&gt;

&lt;p&gt;屋里的壁炉燃烧着熊熊的火焰🔥&lt;/p&gt;

&lt;p&gt;刚睡醒的猫先生伸了个懒腰&lt;/p&gt;

&lt;p&gt;在这种任谁也不会出门的天气&lt;/p&gt;

&lt;p&gt;睡了一天的猫先生还想再多睡一会&lt;/p&gt;

&lt;p&gt;可不行了&lt;/p&gt;

&lt;p&gt;猫太太已经炖好鱼汤了&lt;/p&gt;

&lt;p&gt;猫先生身上的懒虫万万及不上那根馋虫&lt;/p&gt;

&lt;p&gt;所以猫先生起床刷完牙&lt;/p&gt;

&lt;p&gt;舔了舔自己的爪子上了餐桌&lt;/p&gt;

&lt;p&gt;做好饭的猫太太看起来有些生气&lt;/p&gt;

&lt;p&gt;猫先生笑了笑没有说话&lt;/p&gt;

&lt;p&gt;在他邀请猫太太一起用餐无果后&lt;/p&gt;

&lt;p&gt;一个人率先吃喝起来&lt;/p&gt;

&lt;p&gt;猫太太就坐在对面冷冷的盯着他&lt;/p&gt;

&lt;p&gt;在猫先生看向他的时候&lt;/p&gt;

&lt;p&gt;又把目光投向别处&lt;/p&gt;

&lt;p&gt;猫先生见状依旧笑了笑没有说话&lt;/p&gt;

&lt;p&gt;他心里很明白&lt;/p&gt;

&lt;p&gt;猫太太为什么不开心&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;未完待续&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">今天讲的是猫先生和猫太太的故事，有猫先生和猫太太，那猫孩子哪。筒子们，今天的重点是猫先生和猫太太…</summary></entry><entry><title type="html">睡前小故事一则</title><link href="http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi/" rel="alternate" type="text/html" title="睡前小故事一则" /><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi</id><content type="html" xml:base="http://localhost:4000/2018/05/14/shui-qian-xiao-gu-shi/">&lt;blockquote&gt;
  &lt;p&gt;今天的故事背景是在大海里,讲述一只小海豚和一只大黑鲨的故事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在波澜壮阔的大海里&lt;/p&gt;

&lt;p&gt;生长着无数活泼可爱的小生灵&lt;/p&gt;

&lt;p&gt;其中有一只小海豚尤其可爱&lt;/p&gt;

&lt;p&gt;它活泼又聪明&lt;/p&gt;

&lt;p&gt;美丽又善良&lt;/p&gt;

&lt;p&gt;可惜他却有一个对手&lt;/p&gt;

&lt;p&gt;那就是生长在离她不远海域里的大黑鲨&lt;/p&gt;

&lt;p&gt;说到这只大黑鲨&lt;/p&gt;

&lt;p&gt;小海豚每次都要叹口气&lt;/p&gt;

&lt;p&gt;他们认识了好长时间&lt;/p&gt;

&lt;p&gt;一起玩耍一起学习&lt;/p&gt;

&lt;p&gt;一块逃课打架&lt;/p&gt;

&lt;p&gt;但大黑鲨生性内敛&lt;/p&gt;

&lt;p&gt;虽然在一起相处了好多年&lt;/p&gt;

&lt;p&gt;但却谈不上熟悉&lt;/p&gt;

&lt;p&gt;本来这只大黑鲨虽然有些沉闷&lt;/p&gt;

&lt;p&gt;但生性还算善良&lt;/p&gt;

&lt;p&gt;可随着他们相处的日子变长&lt;/p&gt;

&lt;p&gt;他变得越来越凶恶&lt;/p&gt;

&lt;p&gt;虽然没有对她做什么坏事&lt;/p&gt;

&lt;p&gt;可时常骚扰过往的路人&lt;/p&gt;

&lt;p&gt;从一开始吓唬到他们&lt;/p&gt;

&lt;p&gt;到后来掀翻渔人的小船&lt;/p&gt;

&lt;p&gt;要不是海豚🐬跑的快&lt;/p&gt;

&lt;p&gt;大黑鲨怕是要吃人了&lt;/p&gt;

&lt;p&gt;小海豚劝告了他无数次&lt;/p&gt;

&lt;p&gt;可他都是讷讷的不说话&lt;/p&gt;

&lt;p&gt;所以这片海域&lt;/p&gt;

&lt;p&gt;一直上演着一个追一个救的闹剧&lt;/p&gt;

&lt;p&gt;后来有一天&lt;/p&gt;

&lt;p&gt;大黑鲨出事了&lt;/p&gt;

&lt;p&gt;周围的渔人联合起来抓住了这只大黑鲨&lt;/p&gt;

&lt;p&gt;想要杀他求平安&lt;/p&gt;

&lt;p&gt;善良的小海豚于心不忍&lt;/p&gt;

&lt;p&gt;跑去百般求饶&lt;/p&gt;

&lt;p&gt;最后渔人们看在他的救命之恩的份上&lt;/p&gt;

&lt;p&gt;答应给这只鲨鱼一次机会&lt;/p&gt;

&lt;p&gt;渔人们远去后&lt;/p&gt;

&lt;p&gt;海豚望着吓得面如土色的鲨鱼&lt;/p&gt;

&lt;p&gt;叹了口气&lt;/p&gt;

&lt;p&gt;终于忍不住问&lt;/p&gt;

&lt;p&gt;你为什么非要伤害别人哪&lt;/p&gt;

&lt;p&gt;讷讷的鲨鱼可能被吓傻了&lt;/p&gt;

&lt;p&gt;想也没想&lt;/p&gt;

&lt;p&gt;说道：还不是为了引起你的注意&lt;/p&gt;

&lt;p&gt;小海豚万万没想到这个答案&lt;/p&gt;

&lt;p&gt;又羞又气&lt;/p&gt;

&lt;p&gt;问：那你为什么不直接来找我而要去找别人的麻烦&lt;/p&gt;

&lt;p&gt;大黑鲨好像开了窍：因为我会害羞&lt;/p&gt;

&lt;p&gt;海豚扑哧一声笑了&lt;/p&gt;

&lt;p&gt;他什么都没说&lt;/p&gt;

&lt;p&gt;拉着黑鲨的鳍游向了广阔的远方&lt;/p&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">今天的故事背景是在大海里,讲述一只小海豚和一只大黑鲨的故事</summary></entry><entry><title type="html">GitPage, apatch</title><link href="http://localhost:4000/2018/05/14/apatch-gitpage/" rel="alternate" type="text/html" title="GitPage, apatch" /><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/14/apatch-gitpage</id><content type="html" xml:base="http://localhost:4000/2018/05/14/apatch-gitpage/">&lt;blockquote&gt;
  &lt;p&gt;记录一些常见问题的细节备份&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;遇到恼人的权限安装或者删除的权限问题的时候在命令中添加-n-usrlocalbin-即可执行&quot;&gt;遇到恼人的权限安装或者删除的权限问题的时候在命令中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;-n /usr/local/bin&lt;/code&gt; 即可执行&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install -n /usr/local/bin cocoapods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;gitpage-本地调试&quot;&gt;GitPage 本地调试&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//首次本地安装jelly
sudo gem install -n /usr/local/bin jekyll bundler
// 启动本地jeklly 环境
jeklly serve
// 访问
localhost:4000 
//停止jeklly服务
ctrl + c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mac-本地apatch服务开启&quot;&gt;mac 本地Apatch服务开启&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 启动Apache服务
sudo apachectl start
// 重启Apache服务
sudo apachectl restart
// 停止Apache服务
sudo apachectl stop
// 查看Apache版本
httpd -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;step-1&quot;&gt;step 1&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#LoadModule rewrite_module libexec/apache2/mod_rewrite.so
// uncommet this line
LoadModule php7_module libexec/apache2/libphp7.so
#LoadModule perl_module libexec/apache2/mod_perl.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;step-2&quot;&gt;step 2&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#DocumentRoot &quot;/Library/WebServer/Documents&quot;
#&amp;lt;Directory &quot;/Library/WebServer/Documents&quot;&amp;gt;
DocumentRoot &quot;/Users/jason/Sites&quot;
&amp;lt;Directory &quot;/Users/jason/Sites&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;step-3&quot;&gt;step 3&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Options FollowSymLinks Multiviews
 Options Indexes FollowSymLinks Multiviews
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;和谐版的alfred-3-在每次开机后都会提示是否允许访问通讯录的弹窗&quot;&gt;和谐版的Alfred 3 在每次开机后，都会提示“是否允许访问通讯录”的弹窗&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">记录一些常见问题的细节备份</summary></entry><entry><title type="html">私有库创建</title><link href="http://localhost:4000/2018/05/12/podSpec/" rel="alternate" type="text/html" title="私有库创建" /><published>2018-05-12T00:00:00+08:00</published><updated>2018-05-12T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/12/podSpec</id><content type="html" xml:base="http://localhost:4000/2018/05/12/podSpec/">&lt;blockquote&gt;
  &lt;p&gt;cocoaPods 公有库和私有库的创建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;cocoapodspods-公有库创建&quot;&gt;cocoapodsPods 公有库创建&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;pod lib create KKLPush&lt;/li&gt;
  &lt;li&gt;添加文件到 classes中&lt;/li&gt;
  &lt;li&gt;执行 pod install&lt;/li&gt;
  &lt;li&gt;推送到远端&lt;/li&gt;
  &lt;li&gt;添加 tag&lt;/li&gt;
  &lt;li&gt;检查有效性
    &lt;blockquote&gt;
      &lt;p&gt;pod lib lint –allow-warnings&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;blockquote&gt;
      &lt;p&gt;pod trunk push –allow-warnings&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;开课啦cocoapods私有库创建教程&quot;&gt;开课啦CocoaPods私有库创建教程&lt;/h1&gt;

&lt;h3 id=&quot;创建私有-spec-repo&quot;&gt;创建私有 Spec Repo&lt;/h3&gt;

&lt;p&gt;先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。&lt;/p&gt;

&lt;p&gt;因此我们需要创建一个类似于master的私有Spec Repo。我们可以创建一个私有的git仓库当做我们自己的Spec Repo。（已经在公司的gitlab上创建好了名叫&lt;a href=&quot;http://git.mistong.com/ios-framework/mistong-repo&quot;&gt;mistong-repo&lt;/a&gt;的私有Spec Repo）&lt;/p&gt;

&lt;p&gt;创建完成之后在Terminal中执行如下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo add mistong ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时如果成功的话进入到~/.cocoapods/repos目录下就可以看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt; 这个目录了。至此我们的pod就能在本地search到 &lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt; 里申明的所有库了。&lt;/p&gt;

&lt;h3 id=&quot;创建cocoapods私有库&quot;&gt;创建CocoaPods私有库&lt;/h3&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.jianshu.com/p/c6c227c0c221&quot;&gt;CocoaPods建立私有仓库 spec repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们来创建一个私有库，以KKLKit为例。&lt;/p&gt;

&lt;p&gt;在Terminal中执行如下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod lib create KKLKit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后他会问你几个问题，1. 选择开发语言 2.是否需要一个例子工程；3.选择一个测试框架；4.是否基于View测试；5.类的前缀；这几个问题的具体介绍可以去看官方文档，我这里选择的是1.ObjC  ;2.Yes；3.None；4.None；4.KKL。 问完这几个问题他会自动执行pod install命令创建项目并生成依赖。&lt;/p&gt;

&lt;p&gt;_Pods.xcodeproj文件在这里并没有什么作用，可以直接删掉。 其中KKLKit目录仅包含了KKLKit的源文件及图片资源等文件，Example目录则包含了KKLKit相关的demo。我们在编写KKLKit的源码的时候，直接在Example的工程中进行。&lt;/p&gt;

&lt;p&gt;现在我们进入Example目录，打开.workspace文件。
可以看到，Development Pods目录下的KKLKit目录就是我们的库源码。可以直接修改该目录下的代码。需要注意的是，如果需要在KKLKit中增加或删除文件，在增加文件后，需要在Example的根目录，执行一下&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install &lt;/code&gt; 命令。&lt;/p&gt;

&lt;h3 id=&quot;发布私有库&quot;&gt;发布私有库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;编辑podspec文件，发布版本库前，需要先配置好podspec文件，具体模板可以参考&lt;a href=&quot;http://git.mistong.com/ios-framework/CKKit/blob/master/CKKit.podspec&quot;&gt;CKKit.podspec&lt;/a&gt;。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#
# Be sure to run `pod lib lint CKKit.podspec' to ensure this is a
# valid spec before submitting.
#
# Any lines starting with a # are optional, but their use is encouraged
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
#
Pod::Spec.new do |s|
s.name             = 'CKKit'
s.version          = '0.1.11'
s.summary          = 'CKKit是一个工具类的库'
# This description is used to generate tags and improve search results.
#   * Think: What does it do? Why did you write it? What is the focus?
#   * Try to keep it short, snappy and to the point.
#   * Write the description between the DESC delimiters below.
#   * Finally, don't worry about the indent, CocoaPods strips it!
s.description      = &amp;lt;&amp;lt;-DESC
CKKit是一个工具类的库，主要包含容器类、通知、数据源相关的管理类及工具类
                     DESC
s.homepage         = 'http://git.mistong.com/ios-framework/CKKit'
# s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'
s.license          = { :type =&amp;gt; 'MIT', :file =&amp;gt; 'LICENSE' }
s.author           = { 'jiangjunchen' =&amp;gt; 'jiangjunchen@kaike.la' }
s.source           = { :git =&amp;gt; 'ssh://git@git.mistong.com:10022/ios-framework/CKKit.git', :tag =&amp;gt; s.version.to_s }
# s.social_media_url = 'https://twitter.com/&amp;lt;TWITTER_USERNAME&amp;gt;'
# s.module_map = 'CKKit/CKKit.modulemap'
s.ios.deployment_target = '8.0'
s.source_files = 'CKKit/Classes/CKKit.h'
s.subspec 'Base' do |ss|
    ss.source_files = 'CKKit/Classes/Base/**/*'
end
s.subspec 'UIKit' do |ss|
    ss.source_files = 'CKKit/Classes/UIKit/**/*'
    ss.dependency 'CKKit/Base'
end
# s.source_files = 'CKKit/Classes/**/*'
# s.resource_bundles = {
#   'CKKit' =&amp;gt; ['CKKit/Assets/*.png']
# }
# s.public_header_files = 'Pod/Classes/**/*.h'
# s.frameworks = 'UIKit', 'MapKit'
# s.dependency 'AFNetworking', '~&amp;gt; 2.3'
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传后保存会有目录结构&lt;br /&gt;
&lt;img src=&quot;http://note.youdao.com/yws/res/1892/WEBRESOURCEba18671e1fe66bf403fecade8204e488&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;git commit后，需要打tag，并push到远程。如&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;first release&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt; 
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;nt&quot;&gt;--tags&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#推送tag到远端仓库&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;验证私有库的正确性&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod lib lint &lt;span class=&quot;nt&quot;&gt;--allow-warnings&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;验证成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向Spec Repo提交podspec。 向我们的私有Spec Repo提交podspec只需要一个命令&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod repo push mistong ./KKLKit.podspec &lt;span class=&quot;nt&quot;&gt;--allow-warnings&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;mistong&lt;/code&gt;就是我们的私有Spec Repo，&lt;code class=&quot;highlighter-rouge&quot;&gt;./KKLKit.podspec&lt;/code&gt;则是我们私有库的描述文件路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;注如果podspec的依赖包含你自己的私有库那么验证命令后面要填写你所依赖的那个私有库的连接地址和cocoapods的默认地址&quot;&gt;注：如果podspec的依赖包含你自己的私有库。那么验证命令后面要填写你所依赖的那个私有库的连接地址和cocoapods的默认地址&lt;/h4&gt;

&lt;p&gt;如：$ pod lib lint –sources=’ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git,https://github.com/CocoaPods/Specs’ –use-libraries –allow-warnings&lt;/p&gt;

&lt;h3 id=&quot;安装私有库&quot;&gt;安装私有库&lt;/h3&gt;

&lt;p&gt;安装私有库需要在Podfile文件顶部申明一下我们的私有Repo Spec地址，以及pod公共的Repo Spec地址。 再在podfile中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'CKKit', '~&amp;gt; 0.0.1'&lt;/code&gt;来申明私有库&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'ssh://git@git.mistong.com:10022/ios-framework/mistong-repo.git'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://github.com/CocoaPods/Specs.git'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;关于resources&quot;&gt;&lt;a href=&quot;http://blog.xianqu.org/2015/08/pod-resources/&quot;&gt;关于Resources&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;新版的cocoapods推荐在podspec使用&lt;code class=&quot;highlighter-rouge&quot;&gt;resource_bundle&lt;/code&gt;方式引用资源文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.resource_bundle = {'LibName' =&amp;gt; ['LibName/*.png']}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理论上一个 bundle 里可以有一个 asset catalog。Xcode 最后会把它们编译成 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assets.car&lt;/code&gt; 文件。但是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;resource_bundle&lt;/code&gt;这种方式对&lt;code class=&quot;highlighter-rouge&quot;&gt;Image.xcassets&lt;/code&gt;支持不太好，会出现找不到图片的情况。所以增对图片资源，要么不使用xcassets，直接将图片放到文件目录中；要么使用podspec的resources方式添加图片的xcassets。&lt;/p&gt;

&lt;p&gt;我这里推荐采用resources方式添加图片资源，因为pdf格式的图片需要放到xcassets中才能直接使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.resources = 'XHXUser/Assets/**/*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么在代码中可以用如下方式获取pod库中的图片资源:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSBundle *bundle = [NSBundle bundleForClass:[XHXUserAPI class]];
UIImage *image = [UIImage imageNamed:@&quot;LoginLogo&quot; inBundle:bundle compatibleWithTraitCollection:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你可以在pod库内部创建一个宏&lt;code class=&quot;highlighter-rouge&quot;&gt;ModuleImage&lt;/code&gt;，用于获取私有库内部的图片:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// 根据图片名，获取模块内部的图片
#define ModuleImage(name) [UIImage imageNamed:(name) inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]
&lt;/code&gt;&lt;/pre&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">cocoaPods 公有库和私有库的创建</summary></entry><entry><title type="html">眼中的自己</title><link href="http://localhost:4000/2018/05/11/myself/" rel="alternate" type="text/html" title="眼中的自己" /><published>2018-05-11T00:00:00+08:00</published><updated>2018-05-11T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/11/myself</id><content type="html" xml:base="http://localhost:4000/2018/05/11/myself/">&lt;blockquote&gt;
  &lt;p&gt;人的一生最大的敌人是自己，最难看清的也是自己。&lt;/p&gt;

  &lt;p&gt;借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可以信任&lt;/p&gt;

    &lt;p&gt;一般来讲，一件事情如果我应下来，那就会尽力去朝着想要的结果而努力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;热爱阅读&lt;/p&gt;

    &lt;p&gt;不管有用的没用的，我总是在阅读着，也在进行着一些相应的思考。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;拖延症&lt;/p&gt;

    &lt;p&gt;任由事情在自己手上堆积，找各种借口不去开始，即使那件事情只需要两分钟就能处理完。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;必须症&lt;/p&gt;

    &lt;p&gt;对自己身上客观存在的一些东西没有无条件地接受；对别人的行为和这个世界的样子存在期待，一旦不符合期待便会焦虑和自我挫败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;含糊症&lt;/p&gt;

    &lt;p&gt;别人来问我什么问题的时候总是回答得很快，有时候给出的并不是经过思考后最合理最确定的回答，后来反应和发觉过来只好再去补救。其实别人没那么急，略等几秒在脑海里找到确定的答案再答复相对是效率更高的方式，这并不会显得我没有准备和欠思考，实际上它比我立即给出一个不准确的答案而后来再推翻或补充要好。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Peichao Yuan</name></author><summary type="html">人的一生最大的敌人是自己，最难看清的也是自己。 借对自己的审视，借别人口中的评价，更好地了解自己，做更好的自己。</summary></entry></feed>