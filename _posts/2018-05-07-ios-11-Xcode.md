---
layout: post
title: Xcode 9 iOS 11适配
categories: tech
description:  Xcode 9 iOS 11适配
keywords:  Xcode 9, iOS 11
---      

iOS 11, Xcode 9 的一些适配问题 

<div id="detailbody" class="field_body">
                    <p><span style="font-size: 20px;"><strong>一、前言</strong></span></p><p>iOS11发布也有一段时间了，每次版本升级，相关的适配工作当然是下个版本的核心工作之一。而且这次iOS11的更新，相对于iOS10的更新来说，改动点还是比较多的。除了iOS11系统的更新之外，iPhoneX刘海的打理工作也是必不可少。以前我们总是庆幸作为iOS开发者，不必像Android开发者需要考虑各种不同机型的适配问题。但是现在，随着iPhone各种历史版本的存在，各种花式的新版本产生，不同版本之间的适配问题，也是未来我们作为iOS开发者必然要考虑的重要问题之一。</p><p>这次我主要负责我们这边两款App(滴滴代驾司机端+驾管App)iOS11&amp;iPhoneX适配工作。中间也躺过很多坑，一一记录了下来写成这篇文章，既是对自己工作的一次总结，也可以分享给其他iOS开发者，能够让大家少趟一些坑。</p><p>本文将分为三个部分，分别从三方库适配、UI适配、权限适配、补充知识等方面分别进行展开。</p><p><span style="font-size: 20px;"><strong>二、三方库适配问题。</strong></span></p><p><span style="font-size: 18px;"><strong>2.1 CocoaLumberjack 编译出错</strong></span></p><p style="text-align: center;"><span style="font-size: 12px; color: rgb(127, 127, 127);"><strong><img src="http://cc.cocimg.com/api/uploads//20180323/1521771491256554.png" title="1521771491256554.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771491256554.png" alt="1.png"></strong></span></p><p></p><p style="text-align: center;"><span style="font-size: 12px; color: rgb(127, 127, 127);">CocoaLumberjack编译报错</span></p><p><span style="font-size: 18px;"><strong>问题原因：</strong></span></p><p>从错误提示可以看出在Xcode9中os_log_error的第二个参数format必须要为不可变的string类型，而不是char*。</p><p><span style="font-size: 18px;"><strong>解决方案：</strong></span></p><p>我们只要改成如下形式就可以了</p><div><div id="highlighter_584187" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">os_log_error(OS_LOG_DEFAULT,&nbsp;</code><code class="as3 string">"%s"</code><code class="as3 plain">,&nbsp;msg);</code></div></div></td></tr></tbody></table></div></div><p>CocoaLumberjack的作者也在[issue883](<a href="https://link.jianshu.com/?t=https://github.com/Co" target="_blank" _href="https://link.jianshu.com/?t=https://github.com/Co">https://github.com/Co coaLumberjack/CocoaLumberjack/issues/883</a>)中解决了该问题。如果你的工程是pod依赖的话，将pod版本升级到3.3.0版本即可。</p><p><strong><span style="font-size: 18px;">2.2 WebViewJavascriptBridge崩溃处理</span></strong></p><p>我们代驾司机端web容器使用的是WKWebView，jsBridge使用的是WebViewJavascriptBridge这个三方库，更新到Xcode9之后，只要进入WKWebView容器，就会产生如下crash:</p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521771550751368.png" title="1521771550751368.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771550751368.png" alt="1.png"></p><p></p><p style="text-align: center;"><span style="font-size: 12px; color: rgb(127, 127, 127);">WebViewJavascriptBridge crash</span></p><p><span style="font-size: 18px;"><strong>问题原因：</strong></span></p><p>当你使用WKWebView作为你的H5容器的时候，WKNavigationDelegate有个回调就是</p><div><div id="highlighter_225402" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">-&nbsp;(</code><code class="as3 keyword">void</code><code class="as3 plain">)webView:(WKWebView&nbsp;*)webView&nbsp;decidePolicyForNavigationAction:(WKNavigationAction&nbsp;*)navigationAction&nbsp;decisionHandler:(</code><code class="as3 keyword">void</code>&nbsp;<code class="as3 plain">(^)(WKNavigationActionPolicy))decisionHandler;</code></div></div></td></tr></tbody></table></div></div><p>这个回调主要负责根据webView、navigationAction相关信息决定这次跳转是否可以继续进行。调用decisionHandler(WKNavigationActionPolicyAllow);响应这次跳转请求。调用decisionHandler(WKNavigationActionPolicyCancel);就是不响应这次跳转请求。</p><p>查看WebViewJavascriptBridge源码可以看出，在WKWebViewJavascriptBridge.m文件中</p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521771604832877.png" title="1521771604832877.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771604832877.png" alt="1.png"></p><p></p><p style="text-align: center;"><span style="font-size: 12px; color: rgb(127, 127, 127);">WKVebViewCrash.png</span></p><p>在Xcode9中，如果连续看了两次调用decisionHandler方法就会crash。这个问题在之前版本的Xcode均是没有问题的。</p><p><span style="font-size: 18px;"><strong>解决方案：</strong></span></p><ul class=" list-paddingleft-2"><li><p>方案一：修改源码</p><p>在上面代码的149行和150行之间添加return;</p></li><li><p>方案二：pod依赖，原作者没有修改此问题，无法修改源码，也可以在业务代码中进行规避。</p><p>在你自己业务代码的对应对调中添加排除代码，如下：</p></li></ul><p></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521771633371153.png" title="1521771633371153.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771633371153.png" alt="1.png"></p><p style="text-align: center;"><span style="font-size: 12px; color: rgb(127, 127, 127);">WKWebViewCrash2.png</span></p><p><span style="font-size: 18px;"><strong>2.3 LumberjackConsole UI适配</strong></span></p><p style="text-align: center;"><span style="font-size: 18px;"><strong><img src="http://cc.cocimg.com/api/uploads//20180323/1521771742682266.png" title="1521771742682266.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771742682266.png" alt="1.png"></strong></span></p><p></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>iOS7之后，如何你设置self.edgesForExtendedLayout = UIRectEdgeNone的话,系统通过设置UIViewController的automaticallyAdjustsScrollViewInsets属性来自动调整UIScrollView的contentInset，使UIscrollView能够呈现在我们的可是范围之内，而不会被navBar挡住。这个属性在iOS11中被废弃掉了，在iOS11中代替该属性功能的则是UIScrollView类中的contentInsetAdjustmentBehavior和adjustedContentInset属性.在iOS11中用来决定scrollView超出安全区域与边缘距离的属性是adjustedContentInset而不是contentInset。当scrollView超出安全区域时系统会自动调整SafeAreaInsets值，进而影</p><p>响 adjustedContentInset，所以导致scrollView下移20pt或者64pt。当使用自定义的 navigationbar，并且scrollView的frame超出安全区域，SafeAreaInsets为(20,0,0,0);当使用系统的navigationbar，SafeAreaInsets为(64,0,0,0)。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>在UIScrollView或者UITableView初始化的地方，加入如下代码即可。</p><p>针对LumberjackConsole这个开源库，我们可以在PTEConsoleTableView.m文件中的commonInit最后加入如下代码即可。</p><p></p><div><div id="highlighter_459276" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 keyword">if</code><code class="as3 plain">([self&nbsp;respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]){</code></div><div class="line number2 index1 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">[self&nbsp;setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentNever];</code></div><div class="line number3 index2 alt2"><code class="as3 plain">}</code></div></div></td></tr></tbody></table></div></div><p><span style="font-size: 20px;"><strong>三、UI适配</strong></span></p><p><span style="font-size: 18px;"><strong>3.1 NavBar中右上角的customView产生偏移</strong></span></p><p style="text-align: center;"><span style="font-size: 18px;"><strong><img src="http://cc.cocimg.com/api/uploads//20180323/1521771807148487.png" title="1521771807148487.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771807148487.png" alt="1.png"></strong></span></p><p></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>在iOS11中，新的导航视图，使用了AutoLayout布局。而我们这边右上角的两个按钮组合成一个customView，然后把这个customView设置给setRightBarButtonItems而来。customView内部都是frame布局，所以在自动布局下面出错。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>NavBar中的customView里面针对iOS11，均要采用自动布局。</p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521771889744285.png" title="1521771889744285.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771889744285.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>3.2 NavBar中自定义TitleView产生偏移</strong></span></p><p style="text-align: center;"><span style="font-size: 18px;"><strong><img src="http://cc.cocimg.com/api/uploads//20180323/1521771925217984.png" title="1521771925217984.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771925217984.png" alt="1.png"></strong></span></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>同上</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>同上</p><p>这里需要注意一点，自动布局的UI是延迟设置frame的。如果aView采用自动布局。然后你马上调用它的aView.bounds是不正确的。</p><p><span style="font-size: 18px;"><strong>3.3 NavBar中按钮的响应区域都变小了。</strong></span></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521771969320121.png" title="1521771969320121.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521771969320121.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>iOS11之前，虽然我们设置了NavBar上每一个[btn sizeToFit]。苹果依然会帮我们把每一个按钮的点击区域扩大，可以点击区域如上图绿色区域所示。但是在iOS11中，你的按钮的bounds为多大，那你的点击区域就只有多大。估计这个改动也与这次NavBar的大概有关系。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>扩大每一个btn的bounds，而不要使用sizeToFit方法。</p><p><span style="font-size: 18px;"><strong>3.4 NavBar的BarButtonItem无法贴边。有（非plus手机16pt，plus手机20pt）的区域浪费。造成UI偏移，并且最左侧和最右侧区域无法点击。</strong></span></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521772008284264.png" title="1521772008284264.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772008284264.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>这个UINavigationBarContentView平铺在导航栏中作为iOS11的各个按钮的父视图,该视图的所有的子视图都会有一个layoutMargins被占用,也就是系统调整的占位。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>去掉系统默认占位。</p><p>系统并没有提供我们直接去掉系统默认占位的方法，那怎么做呢？</p><p>我们新建一个UINavigationBar的分类，hook住UINavigationBar的layoutSubviews方法。然后遍历View，重新设置layoutMargin约束。</p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521772030450415.png" title="1521772030450415.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772030450415.png" alt="1.png"></p><p style="text-align: center;"><span style="color: rgb(127, 127, 127); font-size: 12px;">重新设置layoutMargin约束</span></p><p><span style="font-size: 18px;"><strong>3.5 UITableView 默认开启Self-Sizing，导致UI显示有问题。</strong></span></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521772063265490.png" title="1521772063265490.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772063265490.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>在iOS11中UITableView会默认使 Self-Sizing,这会导致tableView</p><p>的 estimatedRowHeight 、 estimatedSectionHeaderHeight 、 estimatedSectionFooterHeight 的高度估算属性由默认的0变成 UITableViewAutomaticDimension ,reloadData时可能会导致最后显示的contentSize与预想的不一致;</p><p>同时在iOS11中如果不实现 -tableView: viewForHeaderInSection: 和 tableView: viewForFooterInSection: 方法，则 -tableView: heightForHeaderInSection: 和 - tableView: heightForFooterInSection: 不会被调用，而iOS11之前则没问题。上述都可能会导致界面出现错乱。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>单独关闭摸一个UITableView的Self-Sizing。</p><div><div id="highlighter_757318" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">_tableView.estimatedRowHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">.;</code></div><div class="line number2 index1 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">_tableView.estimatedSectionFooterHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">.;</code></div><div class="line number3 index2 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">_tableView.estimatedSectionHeaderHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">.;</code></div></div></td></tr></tbody></table></div></div><p>关闭所有的UIScroolView、UITableView和UICollectionView的Self-Sizing：</p><div><div id="highlighter_988978" class="syntaxhighlighter  as3 "><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UIScrollView.appearance.contentInsetAdjustmentBehavior&nbsp;=&nbsp;UIScrollViewContentInsetAdjustmentNever;</code></div><div class="line number2 index1 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UITableView.appearance.estimatedRowHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">;</code></div><div class="line number3 index2 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UITableView.appearance.estimatedSectionFooterHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">;</code></div><div class="line number4 index3 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UITableView.appearance.estimatedSectionHeaderHeight&nbsp;=&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">;</code></div></div></td></tr></tbody></table></div></div><p><span style="font-size: 18px;"><strong>3.6 keyWindow获取错误, 导致UI问题。</strong></span></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521772110791559.png" title="1521772110791559.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772110791559.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>机器猫图标是一个UIWindow，windowLevel级别比UIWindowLevelStatusBar还高，所以可以常驻UI最上方。第一次进入该页面，点击“更多”，弹出popView，点击收藏，弹出系统UIAlertView，此时UIAlertView变成了keyWindow。当UIAlertView消失的时候，keyWindow会被谁接管呢？</p><p>iOS11之前，弹出UIAlertView之前的keyWindow是[[UIApplication sharedApplication].delegate window]，那么消失的时候，keyWindow还是[[UIApplication sharedApplication].delegate window]。</p><p>iOS11, 弹出UIAlertView之前的keyWindow是[[UIApplication sharedApplication].delegate window]，那么消失的时候，keyWindow变成z轴最高的UIWindow，即变成了机器猫那个window。所以导致popView被添加到机器猫window中，造成UI样式问题。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>重写自定义UIWindow的becomeKeyWindow的方法，每次自定义window将会变为keyWindow的时候，把keyWindow改成[[UIApplication sharedApplication].delegate window]。</p><p><span style="font-size: 16px;"></span></p><div><div id="highlighter_215343" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">-&nbsp;(</code><code class="as3 keyword">void</code><code class="as3 plain">)becomeKeyWindow{</code></div><div class="line number2 index1 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UIWindow&nbsp;*appWindow&nbsp;=&nbsp;[[UIApplication&nbsp;sharedApplication].delegate&nbsp;window];</code></div><div class="line number3 index2 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">[appWindow&nbsp;makeKeyWindow];</code></div><div class="line number4 index3 alt1"><code class="as3 plain">}</code></div></div></td></tr></tbody></table></div></div><p><span style="font-size: 18px;"><strong>3.7 状态栏高度写死为20pt，导致在iPhoneX上面遮挡住statusBar。</strong></span></p><p style="text-align: center;"><img src="http://cc.cocimg.com/api/uploads//20180323/1521772153502038.png" title="1521772153502038.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772153502038.png" alt="1.png"></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>iPhoneX上的statusBar的高度为44pt，跟其他iPhone型号的20pt不一样。所以以后我们在以statusBar为定位点的时候，不能写死20pt。而要使用[UIApplication sharedApplication].statusBarFrame.size.height来获取，为了方便，可以定义为宏，放到pch文件中，如下：</p><div><div id="highlighter_793724" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">#define&nbsp;kApplicationStatusBarHeight&nbsp;&nbsp;[UIApplication&nbsp;sharedApplication].statusBarFrame.size.height&nbsp;</code><code class="as3 comments">//状态栏的高度</code></div></div></td></tr></tbody></table></div></div><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>状态栏高度定位的时候不要写死20，要使用[UIApplication sharedApplication].statusBarFrame.size.height来获取。</p><p><span style="font-size: 18px;"><strong>补充</strong></span></p><p>iOS11之前导航栏默认高度为64pt(这里高度指statusBar + NavigationBar)，iOS11之后如果设置 prefersLargeTitles = YES则为96pt，默认情况下还是64pt，但在iPhoneX上由于刘海的出现 statusBar由以前的20pt变成 44pt，所以iPhoneX上高度变为88pt，如果项目里隐藏了导航栏加了自定义按钮之类的，这里需要注意适配一下。</p><p><strong><span style="font-size: 18px;">3.8 通过遍历statusBar的subviews中的UIStatusBarDataNetworkItemView获取网络状态在iPhoneX上会crash。</span></strong></p><p>问题原因:</p><p>之前我们采用遍历statusBar，获取UIStatusBarDataNetworkItemView实例，再获取网络状态的。代码如下：</p><div><div id="highlighter_95431" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">+&nbsp;(NSNumber&nbsp;*)&nbsp;dataNetworkTypeFromStatusBar&nbsp;{</code></div><div class="line number2 index1 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">UIApplication&nbsp;*app&nbsp;=&nbsp;[UIApplication&nbsp;sharedApplication];</code></div><div class="line number3 index2 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">NSArray&nbsp;*subviews&nbsp;=&nbsp;[[[app&nbsp;valueForKey:@</code><code class="as3 string">"statusBar"</code><code class="as3 plain">]&nbsp;valueForKey:@</code><code class="as3 string">"foregroundView"</code><code class="as3 plain">]&nbsp;subviews];</code></div><div class="line number4 index3 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">NSNumber&nbsp;*dataNetworkItemView&nbsp;=&nbsp;nil;</code></div><div class="line number5 index4 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div><div class="line number6 index5 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">@</code><code class="as3 keyword">try</code>&nbsp;<code class="as3 plain">{</code></div><div class="line number7 index6 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 keyword">if</code>&nbsp;<code class="as3 plain">([subviews&nbsp;count]&nbsp;&gt;&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">)&nbsp;{</code></div><div class="line number8 index7 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 keyword">for</code>&nbsp;<code class="as3 plain">(id&nbsp;subview&nbsp;</code><code class="as3 keyword">in</code>&nbsp;<code class="as3 plain">subviews)&nbsp;{</code></div><div class="line number9 index8 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 keyword">if</code><code class="as3 plain">([subview&nbsp;isKindOfClass:[NSClassFromString(@</code><code class="as3 string">"UIStatusBarDataNetworkItemView"</code><code class="as3 plain">)&nbsp;</code><code class="as3 color3">class</code><code class="as3 plain">]])&nbsp;{</code></div><div class="line number10 index9 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">dataNetworkItemView&nbsp;=&nbsp;subview;</code></div><div class="line number11 index10 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 keyword">break</code><code class="as3 plain">;</code></div><div class="line number12 index11 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number13 index12 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number14 index13 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number15 index14 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number16 index15 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">@</code><code class="as3 keyword">catch</code>&nbsp;<code class="as3 plain">(NSException&nbsp;*exception)&nbsp;{</code></div><div class="line number17 index16 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number18 index17 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">@</code><code class="as3 keyword">finally</code>&nbsp;<code class="as3 plain">{</code></div><div class="line number19 index18 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 plain">}</code></div><div class="line number20 index19 alt1"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div><div class="line number21 index20 alt2"><code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="as3 keyword">return</code>&nbsp;<code class="as3 plain">[dataNetworkItemView&nbsp;valueForKey:@</code><code class="as3 string">"dataNetworkType"</code><code class="as3 plain">];</code></div><div class="line number22 index21 alt1"><code class="as3 plain">}</code></div></div></td></tr></tbody></table></div></div><p>但是在iphoneX的statusBar的内部结构已经改变，不能根据遍历获取UIStatusBarDataNetworkItemView的状态获取网络状态状态。</p><p>可以通过<strong>po [statusBar recursiveDescription]</strong>打印出来iphoneX内部结构了，可以看出变化非常的大。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>使用AFNetworking中的AFNetworkReachabilityManager类，或者使用<a href="https://link.jianshu.com/?t=https://github.com/tonymillion/Reachability" target="_blank" _href="https://link.jianshu.com/?t=https://github.com/tonymillion/Reachability">Reachability库</a>获取网络连接状态。</p><p><span style="font-size: 20px;"><strong>四、权限适配</strong></span></p><p><span style="font-size: 18px;"><strong>4.1 无法获取定位信息，第一次打开app也无法弹出定位权限提示框</strong></span></p><p><span style="font-size: 18px;"><strong>问题原因:</strong></span></p><p>iOS11 定位相关的权限做了更改，在iOS11上使用了新的定位权限key。</p><p><span style="font-size: 18px;"><strong>解决方案:</strong></span></p><p>如果原来申请的权限是始终允许NSLocationAlwaysUsageDescription，那么需要在保留原来的key的基础上增加NSLocationWhenInUseUsageDescription和NSLocationAlwaysAndWhenInUsageDescription。</p><p><span style="font-size: 20px;"><strong>五、其他一些补充</strong></span></p><p><span style="font-size: 18px;"><strong>5.1 如何判断该设备是不是iPhoneX</strong></span></p><p style="text-align: center;"><span style="font-size: 18px;"><strong><img src="http://cc.cocimg.com/api/uploads//20180323/1521772277385416.png" title="1521772277385416.png" _src="http://cc.cocimg.com/api/uploads//20180323/1521772277385416.png" alt="1.png"></strong></span></p><p><span style="font-size: 18px;"><strong>5.2 一些常用的宏定义</strong></span></p><div><div id="highlighter_427004" class="syntaxhighlighter  as3"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="as3 plain">#define&nbsp;IS_IPHONE_X&nbsp;[KDDeviceHelper&nbsp;is_iPhone_X]</code></div><div class="line number2 index1 alt1"><code class="as3 plain">#define&nbsp;IPHONE_NAVIGATIONBAR_HEIGHT&nbsp;&nbsp;(IS_IPHONE_X&nbsp;?&nbsp;</code><code class="as3 value">88</code>&nbsp;<code class="as3 plain">:&nbsp;</code><code class="as3 value">64</code><code class="as3 plain">)</code></div><div class="line number3 index2 alt2"><code class="as3 plain">#define&nbsp;IPHONE_STATUSBAR_HEIGHT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IS_IPHONE_X&nbsp;?&nbsp;</code><code class="as3 value">44</code>&nbsp;<code class="as3 plain">:&nbsp;</code><code class="as3 value">20</code><code class="as3 plain">)</code></div><div class="line number4 index3 alt1"><code class="as3 plain">#define&nbsp;IPHONE_SAFEBOTTOMAREA_HEIGHT&nbsp;(IS_IPHONE_X&nbsp;?&nbsp;</code><code class="as3 value">34</code>&nbsp;<code class="as3 plain">:&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">)</code></div><div class="line number5 index4 alt2"><code class="as3 plain">#define&nbsp;IPHONE_TOPSENSOR_HEIGHT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IS_IPHONE_X&nbsp;?&nbsp;</code><code class="as3 value">32</code>&nbsp;<code class="as3 plain">:&nbsp;</code><code class="as3 value">0</code><code class="as3 plain">)</code></div></div></td></tr></tbody></table></div></div><p><span style="font-size: 20px;"><strong>六、参考文献</strong></span></p><ul class=" list-paddingleft-2"><li><p><a href="https://www.jianshu.com/p/204455df16d6" target="_blank" _href="https://www.jianshu.com/p/204455df16d6">iOS11&amp;iPhone X适配.pdf</a></p></li><li><p><a href="https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/AZFrqL9dnlgA6Vt2sVhxIw" target="_blank" _href="https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/AZFrqL9dnlgA6Vt2sVhxIw">你可能需要为你的 APP 适配 iOS 11</a></p></li><li><p><a href="https://link.jianshu.com/?t=http://blog.csdn.net/dangyalingengjia/article/details/77964582" target="_blank" _href="https://link.jianshu.com/?t=http://blog.csdn.net/dangyalingengjia/article/details/77964582">升级到XCode9（BaseSDK:iOS11）的各种坑 持续更新中</a></p></li><li><p><a href="https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/2iG4oGzEGm9zQaDOsRgwLA" target="_blank" _href="https://link.jianshu.com/?t=https://mp.weixin.qq.com/s/2iG4oGzEGm9zQaDOsRgwLA">一个iOS 11BUG的发现、定位和解决</a></p></li><li><p><a href="https://www.jianshu.com/p/d40d701889a6" target="_blank" _href="https://www.jianshu.com/p/d40d701889a6">如何判断设备是否为iPhone X，iOS获取设备型号的方法</a></p></li>
